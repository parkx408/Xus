// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, WebSocketConnection, exports, handler, html, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  exports = module.exports = require('./base');

  Connection = require('./transport').Connection;

  html = require('./websocket-html');

  _ = require('./lodash.min');

  exports.startWebSocketServer = function(xusServer, host, port, ready) {
    var app, context;
    app = require('http').createServer(handler);
    context = {
      connections: []
    };
    app.on('upgrade', function(req, socket, head) {
      console.log("upgrade, head: " + (head.toString()));
      return context.connections.push(new WebSocketConnection(xusServer, context, socket, head));
    });
    xusServer.webSocketServer = app;
    xusServer.socketServer = app;
    if (port) {
      return app.listen(port, host, ready);
    } else {
      return app.listen(ready);
    }
  };

  handler = function(req, res) {
    res.writeHead(200);
    return res.end(html);
  };

  WebSocketConnection = (function(_super) {

    __extends(WebSocketConnection, _super);

    function WebSocketConnection(server, context, con, data) {
      var _this = this;
      this.server = server;
      this.context = context;
      this.con = con;
      WebSocketConnection.__super__.constructor.call(this, this.server, null, data.toString());
      console.log("connection data: '" + (data.toString()) + "'");
      this.con.on('data', function(data) {
        return _this.newData(data);
      });
      this.con.on('error', function(hadError) {
        return _this.server.disconnect(_this);
      });
      this.con.on('close', function(hadError) {
        return _this.server.disconnect(_this);
      });
      this.con.on('end', function(hadError) {
        return _this.server.disconnect(_this);
      });
      this.server.addConnection(this);
    }

    WebSocketConnection.prototype.connected = true;

    WebSocketConnection.prototype.write = function(str) {
      return this.con.write(str);
    };

    WebSocketConnection.prototype.basicClose = function() {
      try {
        this.con.end();
      } catch (err) {
        console.log("Error closing connection: " + err.stack);
      }
      return this.context.connections = _.without(this.context.connections, this.con);
    };

    return WebSocketConnection;

  })(Connection);

}).call(this);
