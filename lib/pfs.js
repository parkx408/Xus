// Generated by CoffeeScript 1.3.3
(function() {
  var basicFlock, ex, fs, q, readSome, writeSome;

  q = require('q');

  fs = require('fs-ext');

  ex = module.exports;

  ex.flock = function(fd, flags) {
    if (typeof fd === 'number') {
      return basicFlock(fd, flags);
    } else {
      return fd.then(function(realFd) {
        return basicFlock(realFd, flags);
      });
    }
  };

  ex.open = function(path, flags, mode) {
    return q.ncall(fs.open, fs, path, flags, mode);
  };

  ex.close = function(fd) {
    return q.ncall(fs.close, fs, fd);
  };

  ex.truncate = function(fd, len) {
    return q.ncall(fs.truncate, fs, fd, len);
  };

  ex.mkdir = function(path, mode) {
    return q.ncall(fs.mkdir, fs, path, mode);
  };

  ex.stat = function(path) {
    return q.ncall(fs.stat, fs, path);
  };

  ex.createReadStream = function(path, options) {
    return q.ncall(fs.createReadStream, fs, path, options);
  };

  ex.readFile = function(fd) {
    var done;
    done = q.defer();
    readSome(done, fd, new Buffer(4096), '');
    return done.promise;
  };

  ex.writeFile = function(fd, str) {
    var done;
    done = q.defer();
    writeSome(done, fd, new Buffer(str), 0);
    return done.promise;
  };

  basicFlock = function(fd, flags) {
    return q.ncall(fs.flock, fs, fd, flags);
  };

  readSome = function(d, fd, buf, str) {
    try {
      return fs.read(fd, buf, 0, buf.length, null, function(err, bytesRead, buffer) {
        if (err) {
          return d.reject(err);
        } else if (bytesRead === 0) {
          return d.resolve(str);
        } else {
          return readSome(d, fd, buf, str + buffer.toString(null, 0, bytesRead));
        }
      });
    } catch (err) {
      return d.reject(err);
    }
  };

  writeSome = function(d, fd, buf, bufPos) {
    try {
      return fs.write(fd, buf, bufPos, buf.length - bufPos, null, function(err, written, buf) {
        if (err) {
          return d.reject(err);
        } else if (written === 0) {
          return d.resolve(true);
        } else {
          return writeSome(d, fd, buf, bufPos + written);
        }
      });
    } catch (err) {
      return d.reject(err);
    }
  };

}).call(this);
