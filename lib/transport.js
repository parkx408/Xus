// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, JSONCodec, _;

  _ = require('./lodash.min');

  exports.JSONCodec = JSONCodec = {
    prepare: function(con) {
      return con.saved = '';
    },
    send: function(con, obj) {
      console.log("@@ WRITING @@:" + (JSON.stringify(this.q)));
      return con.write("" + (JSON.stringify(obj)) + "\n");
    },
    newData: function(con, data) {
      var batch, msgs, _i, _len, _ref, _results;
      console.log("saved: " + con.saved);
      msgs = (con.saved + data).split('\n');
      console.log("Received data, saved: " + con.saved + ", msgs: " + (JSON.stringify(msgs)) + ",  data: " + data);
      con.saved = data[data.length - 1] === '\n' ? '' : msgs.pop();
      _ref = _.map(msgs, function(m) {
        console.log("msg: " + m);
        try {
          return JSON.parse(m);
        } catch (err) {
          return ['error', "Could not parse message: " + m];
        }
      });
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        batch = _ref[_i];
        _results.push(con.processBatch(batch));
      }
      return _results;
    }
  };

  exports.Connection = Connection = (function() {

    Connection.prototype.write = function(str) {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'write' method");
    };

    Connection.prototype.close = function() {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'disconnect' method");
    };

    function Connection(master, codec) {
      var _ref;
      this.master = master;
      this.codec = codec;
      this.codec = (_ref = this.codec) != null ? _ref : JSONCodec;
      this.codec.prepare(this);
      this.q = [];
      this.connected = true;
    }

    Connection.prototype.disconnect = function() {
      this.connected = false;
      this.q = null;
      return this.close();
    };

    Connection.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    Connection.prototype.dump = function() {
      if (this.connected && this.q.length) {
        this.codec.send(this, this.q);
        return this.q = [];
      }
    };

    Connection.prototype.newData = function(data) {
      return this.codec.newData(this, data);
    };

    Connection.prototype.processBatch = function(batch) {
      return this.master.processBatch(this, batch);
    };

    return Connection;

  })();

}).call(this);
