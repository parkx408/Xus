// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, DirectConnectionPart, JSONCodec, error_bad_connection, exports, _;

  exports = module.exports = require('./base');

  error_bad_connection = require('./proto').error_bad_connection;

  _ = require('./lodash.min');

  exports.JSONCodec = JSONCodec = {
    prepare: function(con) {},
    send: function(con, obj) {
      return con.write("" + (JSON.stringify(obj)) + "\n");
    },
    newData: function(con, data) {
      var batch, msgs, _i, _len, _ref, _results;
      msgs = (con.saved + data).split('\n');
      con.saved = data[data.length - 1] === '\n' ? '' : msgs.pop();
      _ref = _.map(msgs, function(m) {
        try {
          return JSON.parse(m);
        } catch (err) {
          con.addCmd(['error', "Could not parse message: " + m]);
          return con.send();
        }
      });
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        batch = _ref[_i];
        _results.push(con.processBatch(batch));
      }
      return _results;
    }
  };

  exports.Connection = Connection = (function() {

    Connection.prototype.write = function(str) {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'write' method");
    };

    Connection.prototype.basicClose = function() {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'disconnect' method");
    };

    function Connection(master, codec, saved) {
      var _ref;
      this.master = master;
      this.codec = codec;
      this.saved = saved != null ? saved : '';
      this.codec = (_ref = this.codec) != null ? _ref : JSONCodec;
      this.codec.prepare(this);
      this.q = [];
      this.connected = true;
    }

    Connection.prototype.isConnected = function() {
      return this.connected;
    };

    Connection.prototype.close = function() {
      this.connected = false;
      this.q = null;
      return this.basicClose();
    };

    Connection.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    Connection.prototype.send = function() {
      var q, _ref;
      if (this.connected && this.q.length) {
        _ref = [this.q, []], q = _ref[0], this.q = _ref[1];
        return this.codec.send(this, q);
      }
    };

    Connection.prototype.newData = function(data) {
      return this.codec.newData(this, data);
    };

    Connection.prototype.processBatch = function(batch) {
      return this.master.processBatch(this, batch);
    };

    return Connection;

  })();

  exports.createDirectPeer = function(xus, peerFactory) {
    var ctx, peer, peerConnection, xusConnection;
    ctx = {
      connected: true
    };
    xusConnection = new DirectConnectionPart;
    peerConnection = new DirectConnectionPart;
    peer = peerFactory(peerConnection);
    peerConnection.connect(xusConnection, xus, ctx);
    xusConnection.connect(peerConnection, peer, ctx);
    xus.addConnection(xusConnection);
    return peer;
  };

  DirectConnectionPart = (function() {

    function DirectConnectionPart() {
      this.q = [];
    }

    DirectConnectionPart.prototype.connect = function(otherConnection, otherMaster, ctx) {
      this.otherConnection = otherConnection;
      this.otherMaster = otherMaster;
      this.ctx = ctx;
    };

    DirectConnectionPart.prototype.isConnected = function() {
      return this.ctx.connected;
    };

    DirectConnectionPart.prototype.close = function() {
      this.ctx.connected = false;
      return this.q = this.otherConnection.q = null;
    };

    DirectConnectionPart.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    DirectConnectionPart.prototype.send = function() {
      var q, _ref;
      if (this.ctx.connected && this.q.length) {
        _ref = [this.q, []], q = _ref[0], this.q = _ref[1];
        return this.otherMaster.processBatch(this.otherConnection, q);
      }
    };

    return DirectConnectionPart;

  })();

}).call(this);
