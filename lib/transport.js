// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, ConnectionEndpoint, FdConnection, JSONCodec, ProxyMux, SocketConnection, WebSocketConnection, XusEndpoint, d, error_bad_connection, exports, fs, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  d = (exports = module.exports = require('./base')).d;

  error_bad_connection = require('./proto').error_bad_connection;

  _ = require('./lodash.min');

  fs = require('fs');

  exports.JSONCodec = JSONCodec = {
    prepare: function(con) {},
    send: function(con, obj) {
      return con.write("" + (JSON.stringify(obj)) + "\n");
    },
    newData: function(con, data) {
      var batch, msgs, _i, _len, _ref, _results;
      if (typeof data !== 'string') {
        data = data.toString();
      }
      msgs = (con.saved + data).trim().split('\n');
      con.saved = data[data.length - 1] === '\n' ? '' : msgs.pop();
      _ref = _.map(msgs, function(m) {
        try {
          return JSON.parse(m);
        } catch (err) {
          con.addCmd(['error', "Could not parse message: " + m]);
          return con.send();
        }
      });
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        batch = _ref[_i];
        _results.push(con.processBatch(batch));
      }
      return _results;
    }
  };

  exports.Connection = Connection = (function() {

    Connection.prototype.write = function(str) {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'write' method");
    };

    Connection.prototype.basicClose = function() {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'disconnect' method");
    };

    function Connection(master, codec, saved) {
      var _ref;
      this.master = master;
      this.codec = codec;
      this.saved = saved != null ? saved : '';
      this.codec = (_ref = this.codec) != null ? _ref : JSONCodec;
      try {
        this.codec.prepare(this);
      } catch (err) {
        console.log(err.stack);
      }
      this.q = [];
      this.connected = true;
    }

    Connection.prototype.verbose = function(str) {
      return this.master.verbose(str);
    };

    Connection.prototype.isConnected = function() {
      return this.connected;
    };

    Connection.prototype.close = function() {
      this.connected = false;
      this.q = null;
      return this.basicClose();
    };

    Connection.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    Connection.prototype.send = function() {
      var q, _ref;
      if (this.connected && this.q.length) {
        this.verbose("" + (d(this)) + " SENDING " + this.name + ", " + (JSON.stringify(this.q)));
        _ref = [this.q, []], q = _ref[0], this.q = _ref[1];
        return this.codec.send(this, q);
      }
    };

    Connection.prototype.newData = function(data) {
      this.verbose("" + (d(this)) + " read data: " + data);
      return this.codec.newData(this, data);
    };

    Connection.prototype.processBatch = function(batch) {
      return this.master.processBatch(this, batch);
    };

    return Connection;

  })();

  exports.FdConnection = FdConnection = (function(_super) {

    __extends(FdConnection, _super);

    function FdConnection(input, output) {
      this.input = input;
      this.output = output;
      FdConnection.__super__.constructor.call(this, null, this["null"]);
      this.q = [];
      this.writing = false;
    }

    FdConnection.prototype.setMaster = function(master) {
      this.master = master;
      this.master.addConnection(this);
      return this.read(new Buffer(65536));
    };

    FdConnection.prototype.basicClose = function() {
      fs.close(this.input, function(err) {
        return console.log("Error closing connection: " + err.stack);
      });
      return fs.close(this.output, function(err) {
        return console.log("Error closing connection: " + err.stack);
      });
    };

    FdConnection.prototype.connected = true;

    FdConnection.prototype.read = function(buf) {
      var _this = this;
      return fs.read(this.input, buf, 0, buf.length, null, function(err, bytesRead) {
        if (err) {
          _this.verbose("" + (d(_this)) + " disconnect");
          return _this.master.disconnect(_this);
        } else {
          _this.verbose("" + (d(_this)) + " data '" + data + "'");
          _this.newData(buf.toString(null, 0, bytesRead));
          return _this.read(buf);
        }
      });
    };

    FdConnection.prototype.write = function(str) {
      if (str.length) {
        this.q.push(str);
        if (!this.writing) {
          this.writing = true;
          return this.writeNext();
        }
      }
    };

    FdConnection.prototype.writeNext = function() {
      var buf;
      buf = new Buffer(this.q[0]);
      splice(this.q, 0, 1);
      return writeBuffer(buf);
    };

    FdConnection.prototype.writeBuffer = function(buf) {
      var _this = this;
      return fs.write(this.output, buf, 0, buf.length, null, function(err, written) {
        if (err) {
          _this.verbose("" + (d(_this)) + " disconnect");
          return _this.master.disconnect(_this);
        } else if (written < buf.length) {
          return _this.writeBuffer(buf.slice(written));
        } else if (_this.q.length) {
          return _this.writeNext();
        } else {
          return _this.writing = false;
        }
      });
    };

    return FdConnection;

  })(Connection);

  exports.SocketConnection = SocketConnection = (function(_super) {

    __extends(SocketConnection, _super);

    function SocketConnection(master, con, initialData) {
      var _this = this;
      this.master = master;
      this.con = con;
      SocketConnection.__super__.constructor.call(this, this.master, null, (initialData != null ? initialData : '').toString());
      this.con.on('data', function(data) {
        _this.verbose("" + (d(_this)) + " data: '" + data + "'");
        return _this.newData(data);
      });
      this.con.on('end', function(hadError) {
        _this.verbose("" + (d(_this)) + " disconnect");
        return _this.master.disconnect(_this);
      });
      this.con.on('close', function(hadError) {
        _this.verbose("" + (d(_this)) + " disconnect");
        return _this.master.disconnect(_this);
      });
      this.con.on('error', function(hadError) {
        _this.verbose("" + (d(_this)) + " disconnect");
        return _this.master.disconnect(_this);
      });
      this.master.addConnection(this);
    }

    SocketConnection.prototype.connected = true;

    SocketConnection.prototype.write = function(str) {
      return this.con.write(str);
    };

    SocketConnection.prototype.basicClose = function() {
      try {
        return this.con.destroy();
      } catch (err) {
        return console.log("Error closing connection: " + err.stack);
      }
    };

    return SocketConnection;

  })(Connection);

  exports.WebSocketConnection = WebSocketConnection = (function(_super) {

    __extends(WebSocketConnection, _super);

    function WebSocketConnection(master, con) {
      var _this = this;
      this.master = master;
      this.con = con;
      WebSocketConnection.__super__.constructor.call(this, this.master);
      this.con.onmessage = function(evt) {
        return _this.newData(evt.data);
      };
      this.con.onend = function(hadError) {
        return _this.master.disconnect(_this);
      };
      this.con.onclose = function(hadError) {
        return _this.master.disconnect(_this);
      };
      this.con.onerror = function(hadError) {
        return _this.master.disconnect(_this);
      };
      this.master.addConnection(this);
    }

    WebSocketConnection.prototype.connected = true;

    WebSocketConnection.prototype.write = function(str) {
      this.verbose("" + (d(this)) + " writing: " + str);
      return this.con.send(str);
    };

    WebSocketConnection.prototype.basicClose = function() {
      try {
        return this.con.terminate();
      } catch (err) {
        return console.log("Error closing connection: " + err.stack);
      }
    };

    return WebSocketConnection;

  })(Connection);

  exports.ProxyMux = ProxyMux = (function() {

    function ProxyMux(handler) {
      this.handler = handler;
      this.currentId = 0;
      this.connections = {};
    }

    ProxyMux.prototype.verbose = function() {};

    ProxyMux.prototype.prepare = function() {};

    ProxyMux.prototype.addConnection = function(con) {
      this.verbose("proxy main connection");
      return this.mainConnection = con;
    };

    ProxyMux.prototype.newConnectionEndpoint = function(conFactory) {
      var _this = this;
      return this.newConnection(function(id) {
        var endPoint;
        endPoint = new ConnectionEndpoint(_this, id);
        conFactory(endPoint);
        return endPoint;
      });
    };

    ProxyMux.prototype.newPeer = function() {
      var peer,
        _this = this;
      peer = new exports.Peer;
      peer.con = this.newConnection(function(id) {
        return new XusEndpoint(peer, _this, id);
      });
      this.mainSend([['connect', peer.con.id]]);
      peer.con.newconnection = false;
      return peer;
    };

    ProxyMux.prototype.newConnection = function(factory) {
      var con, id;
      id = this.currentId++;
      con = factory(id);
      this.verbose("proxy got new connection: " + (d(con)) + ", id: " + id);
      this.connections[id] = con;
      return con;
    };

    ProxyMux.prototype.processBatch = function(muxedCon, batch) {
      var b, cmd, con, id, _ref;
      this.verbose("proxy demuxing batch: " + (JSON.stringify(batch)));
      _ref = batch[0], cmd = _ref[0], id = _ref[1];
      con = this.connections[id];
      switch (cmd) {
        case 'connect':
          this.verbose("MUX connect");
          con = new XusEndpoint(this.handler, this, id);
          this.connections[id] = con;
          this.handler.addConnection(con);
          break;
        case 'disconnect':
          this.verbose("MUX disconnect");
          if (con) {
            this.removeConnection(con);
            con.disconnect();
          }
          break;
        case 'data':
          this.verbose("MUX data");
      }
      b = batch.slice(1);
      if (b.length) {
        return this.handler.processBatch(con, b);
      }
    };

    ProxyMux.prototype.disconnect = function(con) {
      if (con === this.mainConnection) {
        return this.mainDisconnect(con);
      } else {
        this.mainSend([['disconnect', con.id]]);
        return this.removeConnection(con);
      }
    };

    ProxyMux.prototype.mainDisconnect = function(con) {
      console.log("Disconnecting mux connection");
      return process.exit();
    };

    ProxyMux.prototype.removeConnection = function(con) {
      var connected;
      if (connected) {
        connected = false;
        return delete this.connections[con.id];
      }
    };

    ProxyMux.prototype.mux = function(endpoint, batch) {
      var b;
      b = batch.slice(0);
      b.splice(0, 0, ['data', endpoint.id]);
      endpoint.newConnection = false;
      return this.mainSend(b);
    };

    ProxyMux.prototype.mainSend = function(batch) {
      this.verbose("" + (d(this)) + " proxy forwarding muxed batch: " + (JSON.stringify(batch)) + " to " + this.mainConnection.constructor.name);
      this.mainConnection.q = batch;
      return this.mainConnection.send();
    };

    ProxyMux.prototype.prepare = function(con) {};

    return ProxyMux;

  })();

  ConnectionEndpoint = (function() {

    function ConnectionEndpoint(mux, id) {
      this.mux = mux;
      this.id = id;
      this.verbose("New ConnectionEndpoint");
      this.newConnection = true;
    }

    ConnectionEndpoint.prototype.verbose = function(str) {
      return this.mux.verbose(str);
    };

    ConnectionEndpoint.prototype.addConnection = function(con) {
      this.con = con;
      this.verbose("ConnectionEndpoint connection: " + this.con.constructor.name);
      this.mux.mainSend([['connect', this.id]]);
      return this.newconnection = false;
    };

    ConnectionEndpoint.prototype.disconnect = function(con) {
      this.verbose("ConnectionEndpoint disconnecting");
      return this.mux.disconnect(this);
    };

    ConnectionEndpoint.prototype.send = function(demuxedBatch) {
      this.verbose("ConnectionEndpoint writing: " + (JSON.stringify(demuxedBatch)));
      this.con.q = demuxedBatch;
      return this.con.send();
    };

    ConnectionEndpoint.prototype.processBatch = function(con, batch) {
      this.verbose("Socket endpoint read: " + batch);
      return this.mux.mux(this, batch);
    };

    return ConnectionEndpoint;

  })();

  XusEndpoint = (function(_super) {

    __extends(XusEndpoint, _super);

    function XusEndpoint(master, proxy, id) {
      this.master = master;
      this.proxy = proxy;
      this.id = id;
      XusEndpoint.__super__.constructor.call(this, this.master, this.proxy);
      this.verbose = this.master.verbose;
    }

    XusEndpoint.prototype.newConnection = false;

    XusEndpoint.prototype.basicClose = function() {
      return this.proxy.disconnect(this);
    };

    XusEndpoint.prototype.send = function() {
      var q, _ref;
      this.verbose("SEND " + (JSON.stringify(this.q)));
      _ref = [this.q, []], q = _ref[0], this.q = _ref[1];
      return this.proxy.mux(this, q);
    };

    XusEndpoint.prototype.disconnect = function() {
      return this.master.disconnect(this);
    };

    return XusEndpoint;

  })(Connection);

}).call(this);
