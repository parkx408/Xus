// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, DirectConnection, JSONCodec, ProxyConnection, ProxyMux, SocketConnection, WebSocketConnection, error_bad_connection, exports, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  exports = module.exports = require('./base');

  error_bad_connection = require('./proto').error_bad_connection;

  _ = require('./lodash.min');

  exports.JSONCodec = JSONCodec = {
    prepare: function(con) {},
    send: function(con, obj) {
      return con.write("" + (JSON.stringify(obj)) + "\n");
    },
    newData: function(con, data) {
      var batch, msgs, _i, _len, _ref, _results;
      if (typeof data !== 'string') {
        data = data.toString();
      }
      msgs = (con.saved + data).trim().split('\n');
      con.saved = data[data.length - 1] === '\n' ? '' : msgs.pop();
      _ref = _.map(msgs, function(m) {
        try {
          return JSON.parse(m);
        } catch (err) {
          con.addCmd(['error', "Could not parse message: " + m]);
          return con.send();
        }
      });
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        batch = _ref[_i];
        _results.push(con.processBatch(batch));
      }
      return _results;
    }
  };

  exports.Connection = Connection = (function() {

    Connection.prototype.write = function(str) {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'write' method");
    };

    Connection.prototype.basicClose = function() {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'disconnect' method");
    };

    function Connection(master, codec, saved) {
      var _ref;
      this.master = master;
      this.codec = codec;
      this.saved = saved != null ? saved : '';
      this.codec = (_ref = this.codec) != null ? _ref : JSONCodec;
      this.codec.prepare(this);
      this.q = [];
      this.connected = true;
    }

    Connection.prototype.isConnected = function() {
      return this.connected;
    };

    Connection.prototype.close = function() {
      this.connected = false;
      this.q = null;
      return this.basicClose();
    };

    Connection.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    Connection.prototype.send = function() {
      var q, _ref;
      if (this.connected && this.q.length) {
        if (this.master.verbose) {
          console.log("SENDING " + this.name + ", " + (JSON.stringify(this.q)));
        }
        _ref = [this.q, []], q = _ref[0], this.q = _ref[1];
        return this.codec.send(this, q);
      }
    };

    Connection.prototype.newData = function(data) {
      return this.codec.newData(this, data);
    };

    Connection.prototype.processBatch = function(batch) {
      return this.master.processBatch(this, batch);
    };

    return Connection;

  })();

  exports.createDirectPeer = function(xus, peerFactory) {
    var ctx, peer, peerConnection, xusConnection;
    ctx = {
      connected: true,
      server: xus
    };
    xusConnection = new DirectConnection;
    peerConnection = new DirectConnection;
    peer = peerFactory(peerConnection);
    peerConnection.connect(xusConnection, xus, ctx);
    xusConnection.connect(peerConnection, peer, ctx);
    xus.addConnection(xusConnection);
    return peer;
  };

  DirectConnection = (function() {

    function DirectConnection() {
      this.q = [];
    }

    DirectConnection.prototype.connect = function(otherConnection, otherMaster, ctx) {
      this.otherConnection = otherConnection;
      this.otherMaster = otherMaster;
      this.ctx = ctx;
    };

    DirectConnection.prototype.isConnected = function() {
      return this.ctx.connected;
    };

    DirectConnection.prototype.close = function() {
      this.ctx.connected = false;
      return this.q = this.otherConnection.q = null;
    };

    DirectConnection.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    DirectConnection.prototype.send = function() {
      var q, _ref;
      if (this.ctx.connected && this.q.length) {
        if (this.ctx.server.verbose) {
          console.log("SENDING " + this.name + ", " + (JSON.stringify(this.q)));
        }
        _ref = [this.q, []], q = _ref[0], this.q = _ref[1];
        return this.otherMaster.processBatch(this.otherConnection, q);
      }
    };

    return DirectConnection;

  })();

  exports.SocketConnection = SocketConnection = (function(_super) {

    __extends(SocketConnection, _super);

    function SocketConnection(master, con, initialData) {
      var _this = this;
      this.master = master;
      this.con = con;
      SocketConnection.__super__.constructor.call(this, this.master, null, (initialData != null ? initialData : '').toString());
      this.con.on('data', function(data) {
        return _this.newData(data);
      });
      this.con.on('end', function(hadError) {
        return _this.master.disconnect(_this);
      });
      this.con.on('close', function(hadError) {
        return _this.master.disconnect(_this);
      });
      this.con.on('error', function(hadError) {
        return _this.master.disconnect(_this);
      });
      this.master.addConnection(this);
    }

    SocketConnection.prototype.connected = true;

    SocketConnection.prototype.write = function(str) {
      return this.con.write(str);
    };

    SocketConnection.prototype.basicClose = function() {
      try {
        return this.con.end();
      } catch (err) {
        return console.log("Error closing connection: " + err.stack);
      }
    };

    return SocketConnection;

  })(Connection);

  exports.WebSocketConnection = WebSocketConnection = (function(_super) {

    __extends(WebSocketConnection, _super);

    function WebSocketConnection(master, con) {
      var _this = this;
      this.master = master;
      this.con = con;
      WebSocketConnection.__super__.constructor.call(this, this.master);
      this.con.on('message', function(data) {
        return _this.newData(data);
      });
      this.con.on('end', function(hadError) {
        return _this.master.disconnect(_this);
      });
      this.con.on('close', function(hadError) {
        return _this.master.disconnect(_this);
      });
      this.con.on('error', function(hadError) {
        return _this.master.disconnect(_this);
      });
      this.master.addConnection(this);
    }

    WebSocketConnection.prototype.connected = true;

    WebSocketConnection.prototype.write = function(str) {
      return this.con.send(str);
    };

    WebSocketConnection.prototype.basicClose = function() {
      try {
        return this.con.terminate();
      } catch (err) {
        return console.log("Error closing connection: " + err.stack);
      }
    };

    return WebSocketConnection;

  })(Connection);

  exports.ProxyMux = ProxyMux = (function() {

    function ProxyMux(handleDemuxedBatch) {
      this.handleDemuxedBatch = handleDemuxedBatch;
      this.currentId = 0;
      this.connections = {};
    }

    ProxyMux.prototype.addConnection = function(con) {
      return this.mainConnection = con;
    };

    ProxyMux.prototype.addPeerConnection = function(conFactory) {
      var can, id;
      can = conFactory(new ProxyConnection(this, id, true));
      id = this.currentId++;
      return this.connections[id] = con;
    };

    ProxyMux.prototype.processBatch = function(con, batch) {
      var cmd, id, _ref;
      _ref = batch[0], cmd = _ref[0], id = _ref[1];
      switch (cmd) {
        case 'connect':
          this.connections[id] = new ProxyConnection(this, id);
          break;
        case 'disconnect':
          delete this.connections[id];
      }
      return this.handleDemuxedBatch(this.connections[id], batch.slice(1));
    };

    ProxyMux.prototype.disconnect = function(con) {};

    return ProxyMux;

  })();

  ProxyConnection = (function(_super) {

    __extends(ProxyConnection, _super);

    function ProxyConnection(mux, id, newConnection) {
      this.mux = mux;
      this.id = id;
      this.newConnection = newConnection;
    }

    ProxyConnection.prototype.send = function() {
      if (this.connected && this.q.length) {
        this.q.splice(0, 0, [(this.newConnection ? 'connect' : 'data'), this.id]);
        if (this.newConnection) {
          this.newConnection = false;
        }
        return ProxyConnection.__super__.send.call(this);
      }
    };

    ProxyConnection.prototype.basicClose = function() {
      this.q.splice(0, 0, ['data', this.id]);
      Connection.prototype.send.call(this);
      return this.mux.removeConnection(this);
    };

    ProxyConnection.prototype.write = function(str) {
      return this.mux.mainConnection.write(str);
    };

    return ProxyConnection;

  })(Connection);

}).call(this);
