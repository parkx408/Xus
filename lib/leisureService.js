// Generated by CoffeeScript 1.3.3
(function() {
  var check, checkDangerous, fs, path, xus,
    __slice = [].slice;

  xus = require('./peer');

  fs = require('fs');

  path = require('path');

  console.log("leisure service");

  module.exports.main = function(master, config) {
    var dir, i;
    i = 0;
    dir = null;
    while (i < config.args.length) {
      if (config.args[i] === '--dir') {
        dir = config.args[++i];
      }
      i++;
    }
    if (!dir) {
      console.log("No directory provided; use --dir directory");
      process.exit(1);
    }
    return fs.realpath(dir, function(err, pth) {
      var peer;
      dir = path.normalize(pth);
      peer = master.newPeer();
      peer.set('this/name', 'local-storage');
      peer.set('this/public/storage', '', 'peer');
      peer.afterConnect(function() {
        console.log("ADDING STORAGE HANDLER");
        return peer.addHandler('this/public/storage', {
          get: function(_arg, errBlock, cont) {
            var key, m, x, _ref;
            x = _arg[0], key = _arg[1];
            if (m = key.match(new RegExp('peer/[^/]+/public/storage(/(.*)|)$'))) {
              console.log("GET FILE REQUEST: " + m[2] + ", DIR: " + dir);
              pth = path.normalize((_ref = m[2]) != null ? _ref : '');
              return checkDangerous(pth, dir, check(errBlock, function() {
                return fs.realpath(path.resolve(dir, pth), check(errBlock, function(pth) {
                  return fs.stat(pth, check(errBlock, function(stats) {
                    if (stats.isDirectory()) {
                      return fs.readdir(pth, check(errBlock, function(files) {
                        var readNext, result;
                        i = 0;
                        result = {};
                        readNext = function() {
                          var child;
                          if (i < files.length) {
                            child = path.normalize("" + pth + "/" + files[i]);
                            return fs.stat(child, check(errBlock, function(stats) {
                              result[child] = {
                                type: stats.isDirectory() ? 'directory' : 'file',
                                size: stats.size,
                                atime: stats.atime,
                                mtime: stats.mtime,
                                ctime: stats.ctime
                              };
                              i++;
                              return readNext();
                            }));
                          } else {
                            return cont(result);
                          }
                        };
                        return readNext();
                      }));
                    } else {
                      return fs.readFile(pth, check(errBlock, function(data) {
                        return cont(data.toString());
                      }));
                    }
                  }));
                }));
              }));
            } else {
              return errBlock('error_bad_peer_request', "Bad storage path: " + key);
            }
          },
          set: function(_arg, errBlock, cont) {
            var key, m, value, x;
            x = _arg[0], key = _arg[1], value = _arg[2];
            console.log("STORING: " + key + " <- " + value);
            if (m = key.match(new RegExp('peer/[^/]+/public/storage/(.+)$'))) {
              return fs.writeFile("" + dir + "/" + m[1], value, function(err) {
                if (err) {
                  return errBlock('error_bad_peer_request', "Couldn't store file " + key + ": " + err);
                } else {
                  return cont(value);
                }
              });
            } else {
              return errBlock('error_bad_peer_request', "Bad storage path: " + key);
            }
          },
          toString: function() {
            return "File Handler for " + dir;
          }
        });
      });
      return peer.set('this/links', ['leisure/storage']);
    });
  };

  check = function(errBlock, block) {
    return function() {
      var args, err;
      err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (err) {
        return errBlock('error_bad_peer_request', err);
      } else {
        return block.apply(null, args);
      }
    };
  };

  checkDangerous = function(file, dir, block) {
    if (path.normalize(path.resolve(dir, file)) === path.join(dir, file)) {
      return block();
    } else {
      return block("Bad file: " + file + " != " + (path.join(dir, file)));
    }
  };

}).call(this);
