// Generated by CoffeeScript 1.3.3
(function() {
  var addFile, addFiles, checkDangerous, createCheck, curDir, fs, listFiles, path, retrieveFile, sendResult, storeFile, xus,
    __slice = [].slice;

  xus = require('./peer');

  fs = require('fs');

  path = require('path');

  curDir = null;

  module.exports.main = function(master) {
    return fs.realpath(process.cwd(), function(err, pth) {
      var peer;
      curDir = path.normalize(pth);
      peer = master.newPeer();
      peer.set('this/public/storage', '', 'peer');
      peer.listen('this/public/storage', function(key, value) {
        switch (key.replace(/^peer\/[^/]*\/public\/storage\/(.*)$/, '$1')) {
          case 'retrieve':
            return retrieveFile(peer, value);
          case 'list':
            return listFiles(peer, value);
          case 'store':
            return storeFile(peer, value);
        }
      });
      return peer.set('this/links', ['leisure/storage']);
    });
  };

  checkDangerous = function(file, block) {
    if (path.normalize(path.resolve(curDir, file)) === path.join(curDir, file)) {
      return block();
    } else {
      return block("Bad file: " + file);
    }
  };

  sendResult = function(key, id, result) {
    return peer.set(responseKey, [id, true, result]);
  };

  createCheck = function(peer, responseKey, id, file) {
    return function(block) {
      return function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err) {
          return peer.set(responseKey, [id, false, "Bad path: " + file]);
        } else {
          return block.apply(null, args);
        }
      };
    };
  };

  retrieveFile = function(peer, _arg) {
    var check, file, id, responseKey;
    responseKey = _arg[0], id = _arg[1], file = _arg[2];
    check = createCheck(peer, responseKey, id, file);
    if (responseKey.match(/^peer\/[^/]\/public/) || !responseKey.match(/^peer\//)) {
      return checkDangerous(file, check(function() {
        return fs.realpath(path.resolve(curDir, file), check(function(pth) {
          return fs.readFile(pth, check(function(data) {
            peer.verbose("Sending file: [" + id + ", true, " + (JSON.stringify(data.toString())) + "]");
            return peer.set(responseKey, [id, true, data.toString()]);
          }));
        }));
      }));
    }
  };

  storeFile = function(peer, _arg) {
    var check, contents, file, id, responseKey;
    responseKey = _arg[0], id = _arg[1], file = _arg[2], contents = _arg[3];
    check = createCheck(peer, responseKey, id, file);
    if (responseKey.match(/^peer\/[^/]\/public/) || !responseKey.match(/^peer\//)) {
      return checkDangerous(file, check(function() {
        var pth;
        pth = path.normalize(path.resolve(curDir, file));
        return fs.writeFile(pth, contents, check(function() {
          peer.verbose("Sending file: [" + id + ", true, " + (JSON.stringify(contents.toString())) + "]");
          return peer.set(responseKey, [id, true]);
        }));
      }));
    }
  };

  listFiles = function(peer, _arg) {
    var check, file, id, responseKey;
    responseKey = _arg[0], id = _arg[1], file = _arg[2];
    check = createCheck(peer, responseKey, id, file);
    return checkDangerous(file, check(function() {
      var output;
      output = [];
      return addFile(peer, check, curDir, output, function() {
        peer.verbose("SENDING FILE LIST: " + (JSON.stringify([id, true, output.slice(1)])));
        return peer.set(responseKey, [id, true, output.slice(1)]);
      });
    }));
  };

  addFile = function(peer, check, file, output, block) {
    return fs.lstat(file, check(function(stats) {
      output.push(file);
      if (stats.isDirectory()) {
        return fs.readdir(file, check(function(files) {
          return addFiles(peer, check, files, output, block);
        }));
      } else {
        return block();
      }
    }));
  };

  addFiles = function(peer, check, files, output, block) {
    if (!files.length) {
      return block();
    } else {
      return addFile(peer, check, files[0], output, check(function() {
        return addFiles(peer, check, files.slice(1), output, block);
      }));
    }
  };

}).call(this);
