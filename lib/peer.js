// Generated by CoffeeScript 1.3.3
(function() {
  var DelegationHandler, DirectConnection, Peer, VarStorage, connectedPeerMethods, d, exports, prefixes, setCmds, _, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  d = (exports = module.exports = require('./base')).d;

  _ref = require('./proto'), setCmds = _ref.setCmds, prefixes = _ref.prefixes, VarStorage = _ref.VarStorage;

  _ = require('./lodash.min');

  exports.Peer = Peer = (function() {

    function Peer(con) {
      this.setConnection(con);
      this.inTransaction = false;
      this.changeListeners = {};
      this.treeListeners = {};
      this.valueListeners = {};
      this.queuedListeners = [];
      this.name = null;
      this.varStorage = new VarStorage(this);
      this.pendingBlocks = [];
    }

    Peer.prototype.afterConnect = function(block) {
      if (this.name) {
        return block();
      } else {
        return this.pendingBlocks.push(block);
      }
    };

    Peer.prototype.setConnection = function(con) {
      var _ref1, _ref2;
      this.con = con;
      this.verbose = ((_ref1 = this.con) != null ? _ref1.verbose : void 0) || (function() {});
      return console.log("ADDED CONNECTION: " + this.con + ", verbose: " + ((((_ref2 = this.con) != null ? _ref2.verbose : void 0) || (function() {})).toString()));
    };

    Peer.prototype.transaction = function(block) {
      this.inTransaction = true;
      block();
      this.inTransaction = false;
      return this.con.send();
    };

    Peer.prototype.send = function(batch) {
      return this.processBatch(this.con, batch);
    };

    Peer.prototype.listen = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.queuedListeners.push(args);
    };

    Peer.prototype.name = function(n) {
      return this.addCmd(['name', n]);
    };

    Peer.prototype.value = function(key, cookie, isTree, callback) {
      this.grabTree(key, callback);
      return this.addCmd(['value', key, cookie, isTree]);
    };

    Peer.prototype.set = function(key, value, storage) {
      return this.addCmd((storage ? ['set', key, value, storage] : ['set', key, value]));
    };

    Peer.prototype.put = function(key, index, value) {
      return this.addCmd(['put', key, value, index]);
    };

    Peer.prototype.splice = function() {
      var key, spliceArgs;
      key = arguments[0], spliceArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.addCmd(['splice', key].concat(__slice.call(spliceArgs)));
    };

    Peer.prototype.removeFirst = function(key, value) {
      return this.addCmd(['removeFirst', key, value]);
    };

    Peer.prototype.removeAll = function(key, value) {
      return this.addCmd(['removeAll', key, value]);
    };

    Peer.prototype.manage = function(key, handler) {};

    Peer.prototype.processBatch = function(con, batch) {
      var block, cmd, k, v, _i, _j, _len, _len1, _ref1, _ref2, _results;
      if (batch[0][0] === 'set' && batch[0][1] === 'this/name') {
        this.name = batch[0][2];
        for (k in connectedPeerMethods) {
          v = connectedPeerMethods[k];
          this[k] = v;
        }
        _ref1 = this.queuedListeners;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          cmd = _ref1[_i];
          this.listen.apply(this, cmd);
        }
        this.queuedListeners = null;
        this.processBatch(con, batch.slice(1));
        _ref2 = this.pendingBlocks;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          block = _ref2[_j];
          _results.push(block());
        }
        return _results;
      }
    };

    Peer.prototype.rename = function(newName) {
      var c, k, listen, newPath, oldName, oldPat, t, thisPat, v, _ref1, _ref2, _ref3;
      newPath = "peer/" + newName;
      thisPat = new RegExp("^this(?=/|$)");
      oldName = (_ref1 = this.name) != null ? _ref1 : 'this';
      this.name = newName;
      exports.renameVars(this.varStorage.keys, this.varStorage.values, oldName, newName);
      t = {};
      _ref2 = this.treeListeners;
      for (k in _ref2) {
        v = _ref2[k];
        t[k.replace(thisPat, newPath)] = v;
      }
      this.treeListeners = t;
      c = {};
      _ref3 = this.changeListeners;
      for (k in _ref3) {
        v = _ref3[k];
        c[k.replace(thisPat, newPath)] = v;
      }
      this.changeListeners = c;
      listen = "peer/" + newName + "/listen";
      if (this.varStorage.values[listen]) {
        oldPat = new RegExp("^peer/" + oldName + "(?=/|$)");
        return this.varStorage.values[listen] = (k.replace(oldPat, newPath)).replace(thisPat, newPath);
      }
    };

    Peer.prototype.sendTreeSets = function(sets, callback) {
      var k, msg, v, x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sets.length; _i < _len; _i++) {
        msg = sets[_i];
        x = msg[0], k = msg[1], v = msg[2];
        _results.push(callback(k, v, null, msg, sets));
      }
      return _results;
    };

    Peer.prototype.tree = function(key, simulate, callback) {
      var idx, msg, msgs, prefix;
      prefix = "^" + key + "(/|$)";
      idx = _.sortedIndex(this.varStorage.keys, key);
      if (simulate) {
        msgs = [];
        while (this.varStorage.keys[idx].match(prefix)) {
          msgs.push(['set', this.varStorage.keys[idx], this.varStorage.values[this.varStorage.keys[idx]]]);
        }
        return this.sendTreeSets(msgs, callback);
      } else {
        msg = ['value', key, null, true];
        while (this.varStorage.keys[idx].match(prefix)) {
          msg.push(this.varStorage.keys[idx], this.varStorage.values[this.varStorage.keys[idx]]);
        }
        return callback(null, null, null, msg, [msg]);
      }
    };

    Peer.prototype.setsForTree = function(msg) {
      var i, key, _i, _len, _ref1, _results, _step;
      _ref1 = msg.slice(4);
      _results = [];
      for (i = _i = 0, _len = _ref1.length, _step = 2; _i < _len; i = _i += _step) {
        key = _ref1[i];
        _results.push(['set', key, msg[i + 1]]);
      }
      return _results;
    };

    Peer.prototype.grabTree = function(key, callback) {
      if (this.name) {
        key = this.personalize(key);
      }
      if (!this.treeListeners[key]) {
        this.treeListeners[key] = [];
      }
      return this.treeListeners[key].push(callback);
    };

    Peer.prototype.personalize = function(path) {
      return path.replace(new RegExp('^this(?=\/|$)'), "peer/" + this.name);
    };

    Peer.prototype.addCmd = function(cmd) {
      this.con.addCmd(cmd);
      if (!this.inTransaction) {
        return this.con.send();
      }
    };

    Peer.prototype.disconnect = function() {
      return this.con.close();
    };

    Peer.prototype.listenersFor = function(key) {
      var _this = this;
      return _.flatten(_.map(prefixes(key), function(k) {
        return _this.changeListeners[k] || [];
      }));
    };

    Peer.prototype.handleDelegation = function(name, num, cmd) {
      var _this = this;
      return this.varStorage.handle(cmd, (function(type, msg) {
        return _this.sendCmd(['error', type, msg]);
      }), function() {
        return _this.sendCmd(['response', num, cmd]);
      });
    };

    Peer.prototype.sendCmd = function(cmd) {
      this.con.addCmd(cmd);
      return this.con.send();
    };

    Peer.prototype.addHandler = function(path, obj) {
      return this.varStorage.addHandler(this.personalize(path), obj);
    };

    return Peer;

  })();

  connectedPeerMethods = {
    processBatch: function(con, batch) {
      var block, cb, cmd, dcmd, index, key, name, num, numKeys, value, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2;
      this.verbose("PEER BATCH: " + (JSON.stringify(batch)));
      numKeys = this.varStorage.keys.length;
      for (_i = 0, _len = batch.length; _i < _len; _i++) {
        cmd = batch[_i];
        name = cmd[0], key = cmd[1], value = cmd[2], index = cmd[3];
        if (__indexOf.call(setCmds, name) >= 0 && !this.varStorage.contains(key)) {
          this.varStorage.keys.push(key);
        }
        switch (name) {
          case 'error':
            console.log("ERROR '" + key + "': value");
            break;
          case 'request':
            console.log("GOT REQUEST: " + (JSON.stringify(cmd)) + ", batch: " + (JSON.stringify(batch)));
            x = cmd[0], name = cmd[1], num = cmd[2], dcmd = cmd[3];
            this.handleDelegation(name, num, dcmd);
            break;
          default:
            this.varStorage.handle(cmd, (function(type, msg) {
              return console.log("Error, '" + type + "': " + msg);
            }), function() {});
        }
      }
      if (numKeys !== this.varStorage.keys.length) {
        this.varStorage.keys.sort();
      }
      for (_j = 0, _len1 = batch.length; _j < _len1; _j++) {
        cmd = batch[_j];
        name = cmd[0], key = cmd[1], value = cmd[2], index = cmd[3];
        if (__indexOf.call(setCmds, name) >= 0) {
          _ref1 = this.listenersFor(key);
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            block = _ref1[_k];
            block(key, this.varStorage.values[key], cmd, batch);
          }
        } else if (name === 'value' && this.treeListeners[key]) {
          _ref2 = this.treeListeners[key];
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            cb = _ref2[_l];
            cb(cmd, batch);
          }
          delete this.treeListeners[key];
        }
      }
      return null;
    },
    listen: function(key, simulateSetsForTree, noChildren, callback) {
      var _ref1,
        _this = this;
      key = key.replace(/^this\//, "peer/" + this.name + "/");
      if (typeof simulateSetsForTree === 'function') {
        noChildren = simulateSetsForTree;
        simulateSetsForTree = false;
      }
      if (typeof noChildren === 'function') {
        callback = noChildren;
        noChildren = false;
      }
      if (noChildren) {
        callback = function(changedKey, value, oldValue, cmd, batch) {
          if (key === changedKey) {
            return callback(changedKey, value, oldValue, cmd, batch);
          }
        };
      }
      if (this.name != null) {
        key = key.replace(new RegExp("^this(?=/|$)"), "peer/" + this.name);
      }
      if (!callback) {
        _ref1 = [null, simulateSetsForTree], simulateSetsForTree = _ref1[0], callback = _ref1[1];
      }
      if (!this.changeListeners[key]) {
        this.changeListeners[key] = [];
        this.grabTree(key, function(msg, batch) {
          if (simulateSetsForTree) {
            _this.sendTreeSets(_this.setsForTree(msg), callback);
          } else {
            callback(key, (msg[4] === key ? msg[5] : null), null, msg, batch);
          }
          return _this.changeListeners[key].push(callback);
        });
        return this.splice("this/listen", -1, 0, key);
      } else {
        return this.tree(key, simulateSetsForTree, callback);
      }
    }
  };

  exports.createDirectPeer = function(xus, peerFactory) {
    var ctx, peer, peerConnection, xusConnection;
    ctx = {
      connected: true,
      server: xus
    };
    xusConnection = new DirectConnection;
    peerConnection = new DirectConnection;
    peerConnection.verbose = xusConnection.verbose = xus.verbose;
    peer = (peerFactory != null ? peerFactory : function(con) {
      return new Peer(con);
    })(peerConnection);
    peerConnection.connect(xusConnection, xus, ctx);
    xusConnection.connect(peerConnection, peer, ctx);
    xus.addConnection(xusConnection);
    return peer;
  };

  DirectConnection = (function() {

    function DirectConnection() {
      this.q = [];
    }

    DirectConnection.prototype.connect = function(otherConnection, otherMaster, ctx) {
      this.otherConnection = otherConnection;
      this.otherMaster = otherMaster;
      this.ctx = ctx;
    };

    DirectConnection.prototype.isConnected = function() {
      return this.ctx.connected;
    };

    DirectConnection.prototype.close = function() {
      this.ctx.connected = false;
      return this.q = this.otherConnection.q = null;
    };

    DirectConnection.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    DirectConnection.prototype.send = function() {
      var q, _ref1;
      if (this.ctx.connected && this.q.length) {
        this.ctx.server.verbose("" + (d(this)) + " SENDING " + this.name + ", " + (JSON.stringify(this.q)));
        _ref1 = [this.q, []], q = _ref1[0], this.q = _ref1[1];
        return this.otherMaster.processBatch(this.otherConnection, q);
      }
    };

    return DirectConnection;

  })();

  DelegationHandler = (function() {

    function DelegationHandler(peer) {
      this.peer = peer;
      this.values = {};
    }

    DelegationHandler.prototype.value = function(reqId, cmd) {};

    DelegationHandler.prototype.set = function(reqId, cmd) {};

    DelegationHandler.prototype.put = function(reqId, cmd) {};

    DelegationHandler.prototype.splice = function(reqId, cmd) {};

    DelegationHandler.prototype.removeFirst = function(reqId, cmd) {};

    DelegationHandler.prototype.removeAll = function(reqId, cmd) {};

    return DelegationHandler;

  })();

}).call(this);
