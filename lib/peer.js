// Generated by CoffeeScript 1.3.3
(function() {
  var Peer, exports, inspect, prefixes, setCmds, _, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports = module.exports = require('./base');

  _ref = require('./proto'), setCmds = _ref.setCmds, prefixes = _ref.prefixes;

  _ = require('./lodash.min');

  inspect = require('util').inspect;

  exports.Peer = Peer = (function() {

    function Peer(con) {
      this.con = con;
      this.inTransaction = false;
      this.changeListeners = {};
      this.treeListeners = {};
      this.values = {};
      this.keys = [];
    }

    Peer.prototype.transaction = function(block) {
      this.inTransaction = true;
      block();
      this.inTransaction = false;
      return this.con.send();
    };

    Peer.prototype.listen = function(key, simulateSetsForTree, callback) {
      var _ref1,
        _this = this;
      if (this.peerName != null) {
        key = key.replace(new RegExp("^this(?=/|$)"), "peer/" + this.peerName);
      }
      if (!callback) {
        _ref1 = [null, simulateSetsForTree], simulateSetsForTree = _ref1[0], callback = _ref1[1];
      }
      if (!this.changeListeners[key]) {
        this.changeListeners[key] = [];
        this.grabTree(key, function(msg) {
          if (simulateSetsForTree) {
            _this.sendTreeSets(_this.setsForTree(msg), callback);
          } else {
            callback(key, (msg[4] === key ? msg[5] : null), null, msg, batch);
          }
          return _this.changeListeners[key].push(callback);
        });
        return this.splice("this/listen", -1, 0, key);
      } else {
        return this.tree(key, simulateSetsForTree, callback);
      }
    };

    Peer.prototype.name = function(n) {
      return this.addCmd(['name', n]);
    };

    Peer.prototype.value = function(key, cookie, isTree, callback) {
      this.grabTree(key, callback);
      return this.addCmd(['value', key, cookie, isTree]);
    };

    Peer.prototype.set = function(key, value) {
      return this.addCmd(['set', key, value]);
    };

    Peer.prototype.put = function(key, index, value) {
      return this.addCmd(['put', key, value, index]);
    };

    Peer.prototype.splice = function() {
      var key, spliceArgs;
      key = arguments[0], spliceArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.addCmd(['splice', key].concat(__slice.call(spliceArgs)));
    };

    Peer.prototype.removeFirst = function(key, value) {
      return this.addCmd(['removeFirst', key, value]);
    };

    Peer.prototype.removeAll = function(key, value) {
      return this.addCmd(['removeAll', key, value]);
    };

    Peer.prototype.processBatch = function(con, batch) {
      var block, cb, cmd, i, idx, index, k, key, msg, name, numKeys, oldValue, type, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _step;
      console.log("Peer batch: " + (JSON.stringify(batch)));
      numKeys = this.keys.length;
      for (_i = 0, _len = batch.length; _i < _len; _i++) {
        cmd = batch[_i];
        name = cmd[0], key = cmd[1], value = cmd[2], index = cmd[3];
        oldValue = __indexOf.call(setCmds, name) >= 0 && this.values[key];
        switch (name) {
          case 'name':
            this.rename(key);
            break;
          case 'set':
            this.values[key] = value;
            break;
          case 'put':
            this.values[key][index] = value;
            break;
          case 'insert':
            if (index < 0) {
              index = this.values[key].length + 1 + index;
            }
            this.values[key] = this.values[key].splice(index, 0, value);
            break;
          case 'removeFirst':
            idx = this.values[key].indexOf(value);
            if (idx > -1) {
              this.values[key] = this.values[key].splice(index, 1);
            }
            break;
          case 'removeAll':
            this.values[key] = _.without(this.values[key], value);
            break;
          case 'value':
            _ref1 = cmd.slice(4);
            for (i = _j = 0, _len1 = _ref1.length, _step = 2; _j < _len1; i = _j += _step) {
              k = _ref1[i];
              if (!(this.values[k] != null)) {
                this.keys.push(k);
              }
              this.values[k] = cmd[i];
            }
            break;
          case 'error':
            name = cmd[0], type = cmd[1], msg = cmd[2];
            console.log(msg);
        }
        if (__indexOf.call(setCmds, name) >= 0) {
          _ref2 = this.listenersFor(key);
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            block = _ref2[_k];
            block(key, this.values[key], oldValue, cmd, batch);
          }
          if (!oldValue) {
            this.keys.push(key);
          }
        } else if (name === 'value' && this.treeListeners[key]) {
          _ref3 = this.treeListeners[key];
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            cb = _ref3[_l];
            cb(cmd, batch);
          }
          delete this.treeListeners[key];
        }
      }
      if (numKeys !== this.keys.length) {
        return this.keys.sort();
      }
    };

    Peer.prototype.rename = function(newName) {
      var c, k, listen, newPath, oldName, oldPat, t, thisPat, v, _ref1, _ref2, _ref3;
      newPath = "peer/" + newName;
      thisPat = new RegExp("^this(?=/|$)");
      oldName = (_ref1 = this.peerName) != null ? _ref1 : 'this';
      this.peerName = newName;
      exports.renameVars(this.keys, this.values, oldName, newName);
      t = {};
      _ref2 = this.treeListeners;
      for (k in _ref2) {
        v = _ref2[k];
        t[k.replace(thisPat, newPath)] = v;
      }
      this.treeListeners = t;
      c = {};
      _ref3 = this.changeListeners;
      for (k in _ref3) {
        v = _ref3[k];
        c[k.replace(thisPat, newPath)] = v;
      }
      this.changeListeners = c;
      listen = "peer/" + newName + "/listen";
      if (this.values[listen]) {
        oldPat = new RegExp("^peer/" + oldName + "(?=/|$)");
        return this.values[listen] = (k.replace(oldPat, newPath)).replace(thisPat, newPath);
      }
    };

    Peer.prototype.showValues = function() {
      return console.log("*** treeListeners: " + (inspect(this.treeListeners)) + "\n*** changeListeners: " + (inspect(this.changeListeners)) + "\n*** values: " + (inspect(this.values)) + "\n*** keys: " + (inspect(this.keys)));
    };

    Peer.prototype.sendTreeSets = function(sets, callback) {
      var k, msg, v, x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sets.length; _i < _len; _i++) {
        msg = sets[_i];
        x = msg[0], k = msg[1], v = msg[2];
        _results.push(callback(k, v, null, msg, sets));
      }
      return _results;
    };

    Peer.prototype.tree = function(key, simulate, callback) {
      var idx, msg, msgs, prefix;
      prefix = "^" + key + "(/|$)";
      idx = _.search(this.keys, key);
      if (simulate) {
        msgs = [];
        while (this.keys[idx].match(prefix)) {
          msgs.push(['set', this.keys[idx], this.values[this.keys[idx]]]);
        }
        return this.sendTreeSets(msgs, callback);
      } else {
        msg = ['value', key, null, true];
        while (this.keys[idx].match(prefix)) {
          msg.push(this.keys[idx], this.values[this.keys[idx]]);
        }
        return callback(null, null, null, msg, [msg]);
      }
    };

    Peer.prototype.setsForTree = function(msg) {
      var i, key, _i, _len, _ref1, _results, _step;
      _ref1 = msg.slice(4);
      _results = [];
      for (i = _i = 0, _len = _ref1.length, _step = 2; _i < _len; i = _i += _step) {
        key = _ref1[i];
        _results.push(['set', key, msg[i + 1]]);
      }
      return _results;
    };

    Peer.prototype.grabTree = function(key, callback) {
      if (this.peerName) {
        key = key.replace(new RegExp("^this(?=/|$)"), "peer/@peerName");
      }
      if (!this.treeListeners[key]) {
        this.treeListeners[key] = [];
      }
      return this.treeListeners[key].push(callback);
    };

    Peer.prototype.addCmd = function(cmd) {
      this.con.addCmd(cmd);
      if (!this.inTransaction) {
        return this.con.send();
      }
    };

    Peer.prototype.disconnect = function() {
      return this.con.close();
    };

    Peer.prototype.listenersFor = function(key) {
      var _this = this;
      return _.flatten(_.map(prefixes(key), function(k) {
        return _this.changeListeners[k] || [];
      }));
    };

    return Peer;

  })();

}).call(this);
