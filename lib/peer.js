// Generated by CoffeeScript 1.3.3
(function() {
  var Peer, exports, prefixes, setCmds, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports = module.exports = require('./base');

  _ref = require('./proto'), setCmds = _ref.setCmds, prefixes = _ref.prefixes;

  exports.Peer = Peer = (function() {

    function Peer(con) {
      this.con = con;
      this.inTransaction = false;
      this.changeListeners = {};
      this.treeListeners = {};
      this.values = {};
      this.keys = [];
    }

    Peer.prototype.transaction = function(block) {
      this.inTransaction = true;
      block();
      this.inTransaction = false;
      return this.con.send();
    };

    Peer.prototype.listen = function(key, simualateSetsForTree, callback) {
      var simulateSetsForTree, _ref1;
      if (!callback) {
        _ref1 = [null, simulateSetsForTree], simulateSetsForTree = _ref1[0], callback = _ref1[1];
      }
      if (!this.changeListeners[key]) {
        this.changeListeners[key] = [];
        this.insert("this/listen", key, -1);
        return this.grabTree(key, function(msg, batch) {
          if (simulateSetsForTree) {
            sendTreeSets(msg, callback);
          } else {
            callback(null, null, msg, batch);
          }
          return this.changeListeners[key].push = callback;
        });
      } else {
        return this.tree(key, simulateSetsForTree, callback);
      }
    };

    Peer.prototype.value = function(key, cookie, isTree, callback) {
      this.grabTree(key, callback);
      return this.addCmd(['tree', key, cookie, isTree]);
    };

    Peer.prototype.set = function(key, value) {
      return this.addCmd(['set', key, value]);
    };

    Peer.prototype.put = function(key, index, value) {
      return this.addCmd(['put', key, value, index]);
    };

    Peer.prototype.insert = function(key, value, index) {
      return this.addCmd(['insert', key, value, index]);
    };

    Peer.prototype.removeFirst = function(key, value) {
      return this.addCmd(['removeFirst', key, value]);
    };

    Peer.prototype.removeAll = function(key, value) {
      return this.addCmd(['removeAll', key, value]);
    };

    Peer.prototype.processBatch = function(con, batch) {
      var block, cb, cmd, idx, index, key, msg, name, newKeys, oldValue, type, value, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2;
      console.log("PEER GOT BATCH: " + batch);
      newKeys = false;
      for (_i = 0, _len = batch.length; _i < _len; _i++) {
        cmd = batch[_i];
        name = cmd[0], key = cmd[1], value = cmd[2], index = cmd[3];
        oldValue = __indexOf.call(setCmds, name) >= 0 && this.values[key];
        switch (name) {
          case 'error':
            name = cmd[0], type = cmd[1], msg = cmd[2];
            console.log(msg);
            break;
          case 'set':
            this.values[key] = value;
            break;
          case 'put':
            this.values[key][index] = value;
            break;
          case 'insert':
            if (index < 0) {
              index = this.values[key].length + 1 + index;
            }
            this.values[key] = this.values[key].splice(index, 0, value);
            break;
          case 'removeFirst':
            idx = this.values[key].indexOf(value);
            if (idx > -1) {
              this.values[key] = this.values[key].splice(index, 1);
            }
            break;
          case 'removeAll':
            this.values[key] = _.without(this.values[key], value);
            break;
          case 'value':
            if (this.treeListeners[key]) {
              _ref1 = this.treeListeners[key];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                cb = _ref1[_j];
                cb(cmd, batch);
              }
            }
        }
        if (__indexOf.call(setCmds, name) >= 0) {
          _ref2 = this.listenersFor(key);
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            block = _ref2[_k];
            block(key, this.values[key], oldValue, cmd, batch);
          }
          if (!oldValue) {
            newKeys = true;
            this.keys.push(key);
          }
        }
      }
      if (newKeys) {
        return sort(this.keys);
      }
    };

    Peer.prototype.sendTreeSets = function(sets, callback) {
      var k, msg, v, x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sets.length; _i < _len; _i++) {
        msg = sets[_i];
        x = msg[0], k = msg[1], v = msg[2];
        _results.push(callback(k, v, null, msg, sets));
      }
      return _results;
    };

    Peer.prototype.tree = function(key, simulate, callback) {
      var idx, msg, msgs, prefix;
      prefix = "^" + key + "(/|$)";
      idx = _.search(this.keys, key);
      if (simulate) {
        msgs = [];
        while (this.keys[idx].match(prefix)) {
          msgs.push(['set', this.keys[idx], this.values[this.keys[idx]]]);
        }
        return this.sendTreeSets(msgs, callback);
      } else {
        msg = ['value', key, null, true];
        while (this.keys[idx].match(prefix)) {
          msg.push(this.keys[idx], this.values[this.keys[idx]]);
        }
        return callback(null, null, null, msg, [msg]);
      }
    };

    Peer.prototype.setsForTree = function(msg) {
      var i, key, _i, _len, _results, _step;
      _results = [];
      for (i = _i = 0, _len = msg.length, _step = 2; _i < _len; i = _i += _step) {
        key = msg[i];
        _results.push(['set', key, msg[i + 1]]);
      }
      return _results;
    };

    Peer.prototype.grabTree = function(key, callback) {
      if (!this.treeListeners[key]) {
        this.treeListeners[key] = [];
      }
      return this.treeListeners[key].push(callback);
    };

    Peer.prototype.addCmd = function(cmd) {
      if (this.inTransaction) {
        return this.con.addCmd(cmd);
      } else {
        this.con.addCmd(cmd);
        return this.con.send();
      }
    };

    Peer.prototype.disconnect = function() {
      return this.con.close();
    };

    Peer.prototype.listenersFor = function(key) {
      return _.flatten(prefixes(key), function(k) {
        return this.changeListeners[k] || [];
      });
    };

    return Peer;

  })();

}).call(this);
