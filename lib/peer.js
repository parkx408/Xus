// Generated by CoffeeScript 1.3.3
(function() {
  var DirectConnection, Peer, d, exports, prefixes, setCmds, _, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  d = (exports = module.exports = require('./base')).d;

  _ref = require('./proto'), setCmds = _ref.setCmds, prefixes = _ref.prefixes;

  _ = require('./lodash.min');

  exports.Peer = Peer = (function() {

    function Peer(con) {
      this.con = con;
      this.inTransaction = false;
      this.changeListeners = {};
      this.treeListeners = {};
      this.values = {};
      this.keys = [];
      this.valueListeners = {};
    }

    Peer.prototype.verbose = function() {};

    Peer.prototype.transaction = function(block) {
      this.inTransaction = true;
      block();
      this.inTransaction = false;
      return this.con.send();
    };

    Peer.prototype.listen = function(key, simulateSetsForTree, noChildren, callback) {
      var _ref1,
        _this = this;
      if (typeof simulateSetsForTree === 'function') {
        noChildren = simulateSetsForTree;
        simulateSetsForTree = false;
      }
      if (typeof noChildren === 'function') {
        callback = noChildren;
        noChildren = false;
      }
      if (noChildren) {
        callback = function(changedKey, value, oldValue, cmd, batch) {
          if (key === changedKey) {
            return callback(changedKey, value, oldValue, cmd, batch);
          }
        };
      }
      if (this.peerName != null) {
        key = key.replace(new RegExp("^this(?=/|$)"), "peer/" + this.peerName);
      }
      if (!callback) {
        _ref1 = [null, simulateSetsForTree], simulateSetsForTree = _ref1[0], callback = _ref1[1];
      }
      if (!this.changeListeners[key]) {
        this.changeListeners[key] = [];
        this.grabTree(key, function(msg, batch) {
          if (simulateSetsForTree) {
            _this.sendTreeSets(_this.setsForTree(msg), callback);
          } else {
            callback(key, (msg[4] === key ? msg[5] : null), null, msg, batch);
          }
          return _this.changeListeners[key].push(callback);
        });
        return this.splice("this/listen", -1, 0, key);
      } else {
        return this.tree(key, simulateSetsForTree, callback);
      }
    };

    Peer.prototype.name = function(n) {
      return this.addCmd(['name', n]);
    };

    Peer.prototype.value = function(key, cookie, isTree, callback) {
      this.grabTree(key, callback);
      return this.addCmd(['value', key, cookie, isTree]);
    };

    Peer.prototype.set = function(key, value, storage) {
      return this.addCmd((storage ? ['set', key, value, storage] : ['set', key, value]));
    };

    Peer.prototype.put = function(key, index, value) {
      return this.addCmd(['put', key, value, index]);
    };

    Peer.prototype.splice = function() {
      var key, spliceArgs;
      key = arguments[0], spliceArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.addCmd(['splice', key].concat(__slice.call(spliceArgs)));
    };

    Peer.prototype.removeFirst = function(key, value) {
      return this.addCmd(['removeFirst', key, value]);
    };

    Peer.prototype.removeAll = function(key, value) {
      return this.addCmd(['removeAll', key, value]);
    };

    Peer.prototype.processBatch = function(con, batch) {
      var block, cb, cmd, i, idx, index, k, key, l, msg, name, numKeys, oldValues, type, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2, _results, _step;
      this.verbose("Peer batch: " + (JSON.stringify(batch)));
      numKeys = this.keys.length;
      oldValues = {};
      for (_i = 0, _len = batch.length; _i < _len; _i++) {
        cmd = batch[_i];
        name = cmd[0], key = cmd[1], value = cmd[2], index = cmd[3];
        if (__indexOf.call(setCmds, name) >= 0) {
          oldValues[key] = this.values[key];
        }
        switch (name) {
          case 'name':
            this.rename(key);
            break;
          case 'set':
            this.values[key] = value;
            break;
          case 'put':
            this.values[key][index] = value;
            break;
          case 'insert':
            if (index < 0) {
              index = this.values[key].length + 1 + index;
            }
            this.values[key] = this.values[key].splice(index, 0, value);
            break;
          case 'removeFirst':
            idx = this.values[key].indexOf(value);
            if (idx > -1) {
              this.values[key] = this.values[key].splice(index, 1);
            }
            break;
          case 'removeAll':
            this.values[key] = _.without(this.values[key], value);
            break;
          case 'value':
            _ref1 = cmd.slice(4);
            for (i = _j = 0, _len1 = _ref1.length, _step = 2; _j < _len1; i = _j += _step) {
              k = _ref1[i];
              if (!(this.values[k] != null)) {
                this.keys.push(k);
              }
              this.values[k] = cmd[i];
            }
            if (l = this.valueListeners[k]) {
              delete this.valueListeners[k];
              for (_k = 0, _len2 = l.length; _k < _len2; _k++) {
                block = l[_k];
                block(cmd);
              }
            }
            break;
          case 'error':
            name = cmd[0], type = cmd[1], msg = cmd[2];
            console.log(msg);
        }
        if (__indexOf.call(setCmds, name) >= 0 && !oldValues[key]) {
          this.keys.push(key);
        }
      }
      if (numKeys !== this.keys.length) {
        this.keys.sort();
      }
      _results = [];
      for (_l = 0, _len3 = batch.length; _l < _len3; _l++) {
        cmd = batch[_l];
        name = cmd[0], key = cmd[1], value = cmd[2], index = cmd[3];
        if (__indexOf.call(setCmds, name) >= 0) {
          _results.push((function() {
            var _len4, _m, _ref2, _results1;
            _ref2 = this.listenersFor(key);
            _results1 = [];
            for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
              block = _ref2[_m];
              _results1.push(block(key, this.values[key], oldValues[key], cmd, batch));
            }
            return _results1;
          }).call(this));
        } else if (name === 'value' && this.treeListeners[key]) {
          _ref2 = this.treeListeners[key];
          for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
            cb = _ref2[_m];
            cb(cmd, batch);
          }
          _results.push(delete this.treeListeners[key]);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Peer.prototype.rename = function(newName) {
      var c, k, listen, newPath, oldName, oldPat, t, thisPat, v, _ref1, _ref2, _ref3;
      newPath = "peer/" + newName;
      thisPat = new RegExp("^this(?=/|$)");
      oldName = (_ref1 = this.peerName) != null ? _ref1 : 'this';
      this.peerName = newName;
      exports.renameVars(this.keys, this.values, oldName, newName);
      t = {};
      _ref2 = this.treeListeners;
      for (k in _ref2) {
        v = _ref2[k];
        t[k.replace(thisPat, newPath)] = v;
      }
      this.treeListeners = t;
      c = {};
      _ref3 = this.changeListeners;
      for (k in _ref3) {
        v = _ref3[k];
        c[k.replace(thisPat, newPath)] = v;
      }
      this.changeListeners = c;
      listen = "peer/" + newName + "/listen";
      if (this.values[listen]) {
        oldPat = new RegExp("^peer/" + oldName + "(?=/|$)");
        return this.values[listen] = (k.replace(oldPat, newPath)).replace(thisPat, newPath);
      }
    };

    Peer.prototype.sendTreeSets = function(sets, callback) {
      var k, msg, v, x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sets.length; _i < _len; _i++) {
        msg = sets[_i];
        x = msg[0], k = msg[1], v = msg[2];
        _results.push(callback(k, v, null, msg, sets));
      }
      return _results;
    };

    Peer.prototype.tree = function(key, simulate, callback) {
      var idx, msg, msgs, prefix;
      prefix = "^" + key + "(/|$)";
      idx = _.search(this.keys, key);
      if (simulate) {
        msgs = [];
        while (this.keys[idx].match(prefix)) {
          msgs.push(['set', this.keys[idx], this.values[this.keys[idx]]]);
        }
        return this.sendTreeSets(msgs, callback);
      } else {
        msg = ['value', key, null, true];
        while (this.keys[idx].match(prefix)) {
          msg.push(this.keys[idx], this.values[this.keys[idx]]);
        }
        return callback(null, null, null, msg, [msg]);
      }
    };

    Peer.prototype.setsForTree = function(msg) {
      var i, key, _i, _len, _ref1, _results, _step;
      _ref1 = msg.slice(4);
      _results = [];
      for (i = _i = 0, _len = _ref1.length, _step = 2; _i < _len; i = _i += _step) {
        key = _ref1[i];
        _results.push(['set', key, msg[i + 1]]);
      }
      return _results;
    };

    Peer.prototype.grabTree = function(key, callback) {
      if (this.peerName) {
        key = key.replace(new RegExp("^this(?=/|$)"), "peer/@peerName");
      }
      if (!this.treeListeners[key]) {
        this.treeListeners[key] = [];
      }
      return this.treeListeners[key].push(callback);
    };

    Peer.prototype.addCmd = function(cmd) {
      this.con.addCmd(cmd);
      if (!this.inTransaction) {
        return this.con.send();
      }
    };

    Peer.prototype.disconnect = function() {
      return this.con.close();
    };

    Peer.prototype.listenersFor = function(key) {
      var _this = this;
      return _.flatten(_.map(prefixes(key), function(k) {
        return _this.changeListeners[k] || [];
      }));
    };

    return Peer;

  })();

  exports.createDirectPeer = function(xus, peerFactory) {
    var ctx, peer, peerConnection, xusConnection;
    ctx = {
      connected: true,
      server: xus
    };
    xusConnection = new DirectConnection;
    peerConnection = new DirectConnection;
    peer = (peerFactory != null ? peerFactory : function(con) {
      return new Peer(con);
    })(peerConnection);
    peerConnection.connect(xusConnection, xus, ctx);
    xusConnection.connect(peerConnection, peer, ctx);
    xus.addConnection(xusConnection);
    return peer;
  };

  DirectConnection = (function() {

    function DirectConnection() {
      this.q = [];
    }

    DirectConnection.prototype.connect = function(otherConnection, otherMaster, ctx) {
      this.otherConnection = otherConnection;
      this.otherMaster = otherMaster;
      this.ctx = ctx;
    };

    DirectConnection.prototype.isConnected = function() {
      return this.ctx.connected;
    };

    DirectConnection.prototype.close = function() {
      this.ctx.connected = false;
      return this.q = this.otherConnection.q = null;
    };

    DirectConnection.prototype.addCmd = function(cmd) {
      return this.q.push(cmd);
    };

    DirectConnection.prototype.send = function() {
      var q, _ref1;
      if (this.ctx.connected && this.q.length) {
        this.ctx.server.verbose("" + (d(this)) + " SENDING " + this.name + ", " + (JSON.stringify(this.q)));
        _ref1 = [this.q, []], q = _ref1[0], this.q = _ref1[1];
        return this.otherMaster.processBatch(this.otherConnection, q);
      }
    };

    return DirectConnection;

  })();

}).call(this);
