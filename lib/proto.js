// Generated by CoffeeScript 1.3.3
(function() {
  var $, Server, caresAbout, cmds, exports, prefixes, setCmds, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports = module.exports;

  $ = require('./jquery-1.7.2.min');

  _ = require('./lodash');

  console.log("jquery: " + jQuery);

  cmds = ['connect', 'set', 'put', 'insert', 'remove', 'removeFirst', 'removeAll'];

  setCmds = ['set', 'put', 'insert', 'removeFirst', 'removeAll'];

  exports.Server = Server = (function() {

    function Server() {}

    Server.prototype.connections = [];

    Server.prototype.peers = {};

    Server.prototype.values = {};

    Server.prototype.transient = {};

    Server.prototype.processMsg = function(con, _arg, msg) {
      var key, name, _i, _len, _ref;
      name = _arg[0], key = _arg[1];
      if (__indexOf.call(cmds, name) >= 0) {
        this[name](con, msg);
        if (__indexOf.call(setCmds, name) >= 0) {
          _ref = this.relevantConnections(prefixes(key));
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            con = _ref[_i];
            con.q.push(msg);
          }
          if (key.match('^peers/listen$')) {
            this.setListening(con, this.values[key]);
          }
          if (!(this.transient[key] === true)) {
            return this.store(key, value);
          }
        }
      } else {
        return this.disconnect(con, "Bad message: " + msg);
      }
    };

    Server.prototype.relevantConnections = function(keyPrefixes) {
      return _.filter(this.connections, function(con) {
        return caresAbout(con, keyPrefixes);
      });
    };

    Server.prototype.addPeer = function(con, name) {
      this.peers[name] = con;
      con.name = name;
      con.listening = {};
      return con.q = [];
    };

    Server.prototype.disconnect = function(con, msg) {
      var idx;
      idx = this.connections.indexOf(con);
      if (idx > -1) {
        this.connections.splice(idx, 1);
        if (con.name) {
          peers[con.name] = null;
        }
        con.q.push(["error", msg]);
        con.dump();
        return this.primDisconnect;
      }
    };

    Server.prototype.setListening = function(con, listening) {
      var old, path, _i, _j, _len, _len1, _results;
      old = con.listening;
      con.listening = {};
      for (_i = 0, _len = listening.length; _i < _len; _i++) {
        path = listening[_i];
        con.listening[path + '/'] = true;
      }
      _results = [];
      for (_j = 0, _len1 = listening.length; _j < _len1; _j++) {
        path = listening[_j];
        if (_.all(prefixes(path), (function(p) {
          return !old[p];
        }))) {
          this.sendAll(con, path);
        }
        _results.push(old[path + '/'] = true);
      }
      return _results;
    };

    Server.prototype.store = function(key, value) {
      throw new Error("Can't store " + key + " = " + (JSON.stringify(value)) + ", because no storage is configured");
    };

    Server.prototype.sendAll = function(con, path) {
      throw new Error("Can't send data for " + path + " because no storage is configured");
    };

    Server.prototype.connect = function(con, _arg) {
      var name, x;
      x = _arg[0], name = _arg[1];
      if (!name) {
        return this.disconnect(con, "No peer name");
      } else if (this.peers[name]) {
        return this.disconnect(con, "Duplicate peer name: " + name);
      } else {
        return this.addPeer(con, name);
      }
    };

    Server.prototype.set = function(con, _arg) {
      var key, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2];
      return this.values[key] = value;
    };

    Server.prototype.put = function(con, _arg) {
      var index, key, value, x;
      x = _arg[0], key = _arg[1], index = _arg[2], value = _arg[3];
      return this.values[key][index] = value;
    };

    Server.prototype.insert = function(con, _arg) {
      var index, key, value, x;
      x = _arg[0], key = _arg[1], index = _arg[2], value = _arg[3];
      if (index === -1) {
        return this.values[key].push(value);
      } else {
        return this.values[key].splice(index, 0, value);
      }
    };

    Server.prototype.removeFirst = function(key, value) {
      var idx, val;
      val = this.values[key];
      idx = val.indexOf(value);
      if (idx > -1) {
        return val.splice(idx, 1);
      }
    };

    Server.prototype.removeAll = function(key, value) {
      var idx, val, _results;
      val = this.values[key];
      _results = [];
      while ((idx = val.indexOf(value)) > -1) {
        _results.push(val.splice(idx, 1));
      }
      return _results;
    };

    return Server;

  })();

  caresAbout = function(con, keyPrefixes) {
    return _.any(keyPrefixes, function(p) {
      return con.listening[p] === true;
    });
  };

  prefixes = function(key) {
    var result, splitKey;
    result = [];
    splitKey = _without(key.split('/'), '');
    while (splitKey.length) {
      result.push(splitKey.join('/'));
      splitKey.pop();
    }
    return result;
  };

}).call(this);
