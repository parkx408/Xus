// Generated by CoffeeScript 1.3.3
(function() {
  var Server, caresAbout, cmds, error_bad_connection, error_bad_master, error_bad_message, error_bad_storage_mode, error_duplicate_peer_name, error_private_variable, error_variable_not_array, error_variable_not_object, exports, keysForPrefix, prefixes, renameVars, setCmds, storageModes, storage_memory, storage_permanent, storage_transient, warning_no_storage, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports = module.exports = require('./base');

  require('./transport');

  _ = require('./lodash.min');

  cmds = ['value', 'set', 'put', 'splice', 'removeFirst', 'removeAll'];

  exports.setCmds = setCmds = ['set', 'put', 'splice', 'removeFirst', 'removeAll'];

  warning_no_storage = 'warning_no_storage';

  error_bad_message = 'error_bad_message';

  error_bad_storage_mode = 'error_bad_storage_mode';

  error_variable_not_object = 'error_variable_not_object';

  error_variable_not_array = 'error_variable_not_array';

  error_bad_connection = 'error_bad_connection';

  error_duplicate_peer_name = 'error_duplicate_peer_name';

  error_private_variable = 'error_private_variable';

  error_bad_master = 'error_bad_master';

  storage_memory = 'memory';

  storage_transient = 'transient';

  storage_permanent = 'permanent';

  storageModes = [storage_transient, storage_memory, storage_permanent];

  exports.Server = Server = (function() {

    Server.prototype.verbose = function() {};

    Server.prototype.newKeys = false;

    Server.prototype.anonymousPeerCount = 0;

    function Server() {
      this.connections = [];
      this.peers = {};
      this.values = {};
      this.keys = [];
      this.storageModes = {};
    }

    Server.prototype.createPeer = function(peerFactory) {
      return exports.createDirectPeer(this, peerFactory);
    };

    Server.prototype.processBatch = function(con, batch) {
      var c, msg, _i, _j, _len, _len1, _ref, _results;
      this.verbose("RECEIVED " + (JSON.stringify(batch)));
      for (_i = 0, _len = batch.length; _i < _len; _i++) {
        msg = batch[_i];
        this.processMsg(con, msg, msg);
      }
      if (this.newKeys) {
        this.newKeys = false;
        this.keys.sort();
      }
      if (this.newListens) {
        this.setListens(con);
        this.newListens = false;
      }
      _ref = this.connections;
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        c = _ref[_j];
        _results.push(c.send());
      }
      return _results;
    };

    Server.prototype.processMsg = function(con, _arg, msg) {
      var c, isSetter, key, name, _i, _len, _ref;
      name = _arg[0], key = _arg[1];
      this.verbose("Xus add connection");
      if (con.isConnected()) {
        if (__indexOf.call(cmds, name) >= 0) {
          isSetter = __indexOf.call(setCmds, name) >= 0;
          if (typeof key === 'string') {
            key = msg[1] = key.replace(new RegExp('^this/'), "peer/" + con.name + "/");
          }
          if (key.match("^peer/") && !key.match("^" + con.peerPath + "/") && !key.match("^peer/[^/]+/public")) {
            return this.disconnect(con, error_private_variable, "Error, " + con.name + " (key = " + key + ", peerPath = " + con.peerPath + ", match = " + (key.match("^" + con.peerPath)) + ") attempted to change another peer's private variable: '" + key + "' in message: " + (JSON.stringify(msg)));
          } else {
            if (isSetter && key === con.listenPath) {
              this.newListens = true;
            }
            if ((this[name](con, msg, msg)) && isSetter) {
              if (key === ("" + con.peerPath + "/name")) {
                this.name(con, msg[2]);
              } else if (key === ("" + con.peerPath + "/master")) {
                this.setMaster(con, msg[2]);
              }
              _ref = this.relevantConnections(prefixes(key));
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                c = _ref[_i];
                this.addCmd(c, msg);
              }
              if (this.storageModes[key] === storage_permanent) {
                return this.store(con, key, value);
              }
            }
          }
        } else {
          return this.disconnect(con, error_bad_message, "Unknown command, '" + name + "' in message: " + (JSON.stringify(msg)));
        }
      }
    };

    Server.prototype.addCmd = function(con, msg) {
      var k, v, _i, _len;
      for (k = _i = 0, _len = msg.length; _i < _len; k = ++_i) {
        v = msg[k];
        msg[k] = this.getValue(v);
      }
      return con.addCmd(msg);
    };

    Server.prototype.relevantConnections = function(keyPrefixes) {
      return _.filter(this.connections, function(c) {
        return caresAbout(c, keyPrefixes);
      });
    };

    Server.prototype.setConName = function(con, name) {
      con.name = name;
      con.peerPath = "peer/" + name;
      con.listenPath = "" + con.peerPath + "/listen";
      this.peers[name] = con;
      return this.values["" + con.peerPath + "/name"] = name;
    };

    Server.prototype.addConnection = function(con) {
      this.verbose("Xus add connection");
      this.setConName(con, "@anonymous-" + (this.anonymousPeerCount++));
      con.listening = {};
      this.connections.push(con);
      this.values[con.listenPath] = [];
      con.addCmd(['set', 'this/name', con.name]);
      return con.send();
    };

    Server.prototype.renamePeerVars = function(con, oldName, newName) {
      var l, newCL, newPrefix, newVL, oldPrefixPat;
      this.keys = renameVars(this.keys, this.values, oldName, newName)[0];
      newCL = {};
      newVL = [];
      newPrefix = "peer/" + newName;
      oldPrefixPat = new RegExp("^peer/" + oldName + "(?=/|$)");
      for (l in con.listening) {
        l = l.replace(oldPrefixPat, newPrefix);
        newCL[l] = true;
        newVL.push(l);
      }
      con.listening = newCL;
      newVL.sort();
      return this.values["" + newPrefix + "/listen"] = newVL;
    };

    Server.prototype.disconnect = function(con, errorType, msg) {
      var idx, key, peerKey, peerKeys, _i, _len;
      idx = this.connections.indexOf(con);
      if (idx > -1) {
        peerKey = "peer/" + con.name;
        peerKeys = this.keysForPrefix(peerKey);
        if (con.name) {
          delete this.peers[con.name];
        }
        for (_i = 0, _len = peerKeys.length; _i < _len; _i++) {
          key = peerKeys[_i];
          this.removeKey(key);
        }
        this.connections.splice(idx, 1);
        if (msg) {
          this.error(con, errorType, msg);
        }
        con.send();
        con.close();
        if (con === this.master) {
          this.exit();
        }
      }
      return false;
    };

    Server.prototype.exit = function() {
      return console.log("No custom exit function");
    };

    Server.prototype.keysForPrefix = function(pref) {
      return keysForPrefix(this.keys, this.values, pref);
    };

    Server.prototype.setListens = function(con) {
      var conPath, finalListen, old, path, thisPath, _i, _len, _ref;
      thisPath = new RegExp("^this/");
      conPath = "" + con.peerPath + "/";
      old = con.listening;
      con.listening = {};
      finalListen = [];
      _ref = this.values[con.listenPath];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        if (path.match("^peer/") && !path.match("^peer/[^/]+/public") && !path.match("^" + con.peerPath)) {
          this.disconnect(con, error_private_variable, "Error, " + con.name + " attempted to listen to a peer's private variables in message: " + (JSON.stringify(msg)));
          return;
        }
        path = path.replace(thisPath, conPath);
        finalListen.push(path);
        con.listening[path] = true;
        if (_.all(prefixes(path), (function(p) {
          return !old[p];
        }))) {
          this.sendTree(con, path, ['value', path, null, true]);
        }
        old[path] = true;
      }
      return this.values[con.listenPath] = finalListen;
    };

    Server.prototype.error = function(con, errorType, msg) {
      con.addCmd(['error', errorType, msg]);
      return false;
    };

    Server.prototype.removeKey = function(key) {
      var idx;
      delete this.storageModes[key];
      delete this.values[key];
      idx = _.search(key, this.keys);
      if (idx > -1) {
        return this.keys.splice(idx, 1);
      }
    };

    Server.prototype.sendTree = function(con, path, cmd) {
      var key, _i, _len, _ref;
      _ref = this.keysForPrefix(path);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        cmd.push(key, this.getValue(this.values[key]));
      }
      return con.addCmd(cmd);
    };

    Server.prototype.getValue = function(value) {
      if (typeof value === 'function') {
        return value();
      } else {
        return value;
      }
    };

    Server.prototype.name = function(con, name) {
      if (!(name != null)) {
        return this.disconnect(con, error_bad_message, "No name given in name message");
      } else if (this.peers[name]) {
        return this.disconnect(con, error_duplicate_peer_name, "Duplicate peer name: " + name);
      } else {
        delete this.peers[con.name];
        this.renamePeerVars(con, con.name, name);
        this.setConName(con, name);
        return con.addCmd(['set', 'this/name', name]);
      }
    };

    Server.prototype.setMaster = function(con, value) {
      if ((this.master != null) && this.master !== con) {
        return this.disconnect(con, error_bad_master, "Xus cannot serve two masters");
      } else {
        this.master = value ? con : null;
        return con.addCmd(['set', 'this/master', value]);
      }
    };

    Server.prototype.store = function(con, key, value) {
      return this.error(con, warning_no_storage, "Can't store " + key + " = " + (JSON.stringify(value)) + ", because no storage is configured");
    };

    Server.prototype.remove = function(con, key) {
      return this.error(con, warning_no_storage, "Can't delete " + key + ", because no storage is configured");
    };

    Server.prototype.value = function(con, _arg, cmd) {
      var cookie, key, tree, x;
      x = _arg[0], key = _arg[1], cookie = _arg[2], tree = _arg[3];
      if (tree) {
        return this.sendTree(con, key, cmd);
      } else {
        if (this.values[key] != null) {
          cmd.push(key, this.getValue(this.values[key]));
        }
        return con.addCmd(cmd);
      }
    };

    Server.prototype.set = function(con, _arg, cmd) {
      var key, storageMode, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2], storageMode = _arg[3];
      if (storageMode && storageModes.indexOf(storageMode) === -1) {
        return this.error(con, error_bad_storage_mode, "" + storageMode + " is not a valid storage mode");
      } else if (this.values[key] === value) {
        return false;
      } else {
        if (storageMode && storageMode !== this.storageModes[key] && this.storageModes[key] === storage_permanent) {
          this.remove(con, key);
        }
        if ((storageMode || this.storageModes[key]) !== storage_transient) {
          if (!this.storageModes[key]) {
            storageMode = storageMode || storage_memory;
            this.keys.push(key);
            this.newKeys = true;
          }
          this.values[key] = value;
        }
        if (storageMode) {
          this.storageModes[key] = storageMode;
        }
        cmd[2] = value;
        return true;
      }
    };

    Server.prototype.put = function(con, _arg) {
      var index, key, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2], index = _arg[3];
      if (!this.values[key] || typeof this.values[key] !== 'object') {
        return this.disconnect(con, error_variable_not_object, "Can't put with " + key + " because it is not an object");
      } else {
        this.values[key][index] = value;
        return true;
      }
    };

    Server.prototype.splice = function(con, _arg, cmd) {
      var args, del, index, key, x, _ref;
      x = _arg[0], key = _arg[1], index = _arg[2], del = _arg[3];
      if (!(this.values[key] instanceof Array)) {
        return this.disconnect(con, error_variable_not_array, "Can't insert into " + key + " because it is not an array");
      } else {
        args = cmd.slice(2);
        if (index < 0) {
          args[0] = this.values[key].length + index + 1;
        }
        (_ref = this.values[key]).splice.apply(_ref, args);
        return true;
      }
    };

    Server.prototype.removeFirst = function(con, _arg) {
      var idx, key, val, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2];
      if (!(this.values[key] instanceof Array)) {
        return this.disconnect(con, error_variable_not_array, "Can't insert into " + key + " because it is not an array");
      } else {
        val = this.values[key];
        idx = val.indexOf(value);
        if (idx > -1) {
          val.splice(idx, 1);
        }
        return true;
      }
    };

    Server.prototype.removeAll = function(con, _arg) {
      var idx, key, val, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2];
      if (!(this.values[key] instanceof Array)) {
        return this.disconnect(con, error_variable_not_array, "Can't insert into " + key + " because it is not an array");
      } else {
        val = this.values[key];
        while ((idx = val.indexOf(value)) > -1) {
          val.splice(idx, 1);
        }
        return true;
      }
    };

    return Server;

  })();

  exports.renameVars = renameVars = function(keys, values, oldName, newName) {
    var k, key, newKey, newPrefix, oldPrefix, oldPrefixPat, trans, _i, _len, _ref;
    oldPrefix = "peer/" + oldName;
    newPrefix = "peer/" + newName;
    oldPrefixPat = new RegExp("^" + oldPrefix + "(?=/|$)");
    trans = {};
    _ref = keysForPrefix(keys, values, oldPrefix);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      newKey = key.replace(oldPrefixPat, newPrefix);
      values[newKey] = values[key];
      trans[key] = newKey;
      delete values[key];
    }
    keys = (function() {
      var _results;
      _results = [];
      for (k in values) {
        _results.push(k);
      }
      return _results;
    })();
    keys.sort();
    return [keys, trans];
  };

  keysForPrefix = function(keys, values, prefix) {
    var idx, prefixPattern;
    keys = [];
    idx = _.search(prefix, keys);
    if (idx > -1) {
      prefixPattern = "^" + prefix + "/";
      if (values[prefix] != null) {
        keys.push(prefix);
      }
      while (keys[++idx] && keys[idx].match(prefixPattern)) {
        if (values[prefix] != null) {
          keys.push(keys[idx]);
        }
      }
    }
    return keys;
  };

  caresAbout = function(con, keyPrefixes) {
    return _.any(keyPrefixes, function(p) {
      return con.listening[p];
    });
  };

  exports.prefixes = prefixes = function(key) {
    var result, splitKey;
    result = [];
    splitKey = _.without(key.split('/'), '');
    while (splitKey.length) {
      result.push(splitKey.join('/'));
      splitKey.pop();
    }
    return result;
  };

  _.search = function(key, arr) {
    var left, mid, right;
    if (arr.length === 0) {
      return 0;
    }
    left = 0;
    right = arr.length - 1;
    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (arr[mid] === key) {
        return mid;
      } else if (arr[mid] < key) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    if (arr[left] < key) {
      return left + 1;
    } else {
      return left;
    }
  };

}).call(this);
