// Generated by CoffeeScript 1.6.3
(function() {
  var Server, VarStorage, caresAbout, cmds, error_bad_master, error_bad_message, error_bad_peer_request, error_bad_storage_mode, error_duplicate_peer_name, error_private_variable, error_variable_not_array, error_variable_not_object, exports, keysForPrefix, prefixes, renameVars, setCmds, storageModes, storage_memory, storage_peer, storage_permanent, storage_transient, warning_no_storage, warning_peer_request, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  require('source-map-support').install();

  exports = module.exports = require('./base');

  require('./transport');

  _ = require('./lodash.min');

  cmds = ['response', 'value', 'set', 'put', 'splice', 'removeFirst', 'removeAll'];

  exports.setCmds = setCmds = ['set', 'put', 'splice', 'removeFirst', 'removeAll'];

  warning_no_storage = 'warning_no_storage';

  warning_peer_request = 'warning_peer_request';

  error_bad_message = 'error_bad_message';

  error_bad_storage_mode = 'error_bad_storage_mode';

  error_variable_not_object = 'error_variable_not_object';

  error_variable_not_array = 'error_variable_not_array';

  error_duplicate_peer_name = 'error_duplicate_peer_name';

  error_private_variable = 'error_private_variable';

  error_bad_master = 'error_bad_master';

  error_bad_peer_request = 'error_bad_peer_request';

  storage_memory = 'memory';

  storage_transient = 'transient';

  storage_permanent = 'permanent';

  storage_peer = 'peer';

  storageModes = [storage_transient, storage_memory, storage_permanent, storage_peer];

  exports.Server = Server = (function() {
    Server.prototype.verbose = function() {};

    Server.prototype.newKeys = false;

    Server.prototype.anonymousPeerCount = 0;

    function Server() {
      console.log("NEW XUS SERVER");
      this.connections = [];
      this.peers = {};
      this.varStorage = new VarStorage(this);
      this.storageModes = {};
      this.linksToPeers = {};
      this.changedLinks = null;
      this.pendingRequests = {};
      this.pendingRequestNum = 0;
    }

    Server.prototype.createPeer = function(peerFactory) {
      return exports.createDirectPeer(this, peerFactory);
    };

    Server.prototype.newPeer = function() {
      return this.createPeer(function(con) {
        return new xus.Peer(con);
      });
    };

    Server.prototype.processBatch = function(con, batch, nolinks) {
      var c, msg, _i, _j, _len, _len1, _ref, _results;
      while (batch.length) {
        this.nextBatch = [];
        for (_i = 0, _len = batch.length; _i < _len; _i++) {
          msg = batch[_i];
          this.verbose("RECEIVED " + (JSON.stringify(msg)));
          this.processMsg(con, msg, msg, nolinks);
        }
        nolinks = true;
        this.varStorage.sortKeys();
        if (this.newListens) {
          this.setListens(con);
          this.newListens = false;
        }
        if (this.newConLinks) {
          this.setLinks(con);
          this.newConLinks = false;
        }
        if (this.changedLinks) {
          this.processLinks(con, this.changedLinks);
          this.changedLinks = null;
        }
        batch = this.nextBatch;
      }
      _ref = this.connections;
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        c = _ref[_j];
        _results.push(c != null ? c.send() : void 0);
      }
      return _results;
    };

    Server.prototype.processMsg = function(con, _arg, msg, noLinks) {
      var isMyPeerKey, key, name, tmpMsg, x, x1, x2,
        _this = this;
      name = _arg[0];
      console.log("@@@@@");
      console.log("*** processMsg: " + msg);
      if (con.isConnected()) {
        if (__indexOf.call(cmds, name) >= 0) {
          if (name === 'response') {
            x1 = msg[0], x2 = msg[1], tmpMsg = msg[2];
          } else {
            tmpMsg = msg;
          }
          x = tmpMsg[0], key = tmpMsg[1];
          if (typeof key === 'string') {
            key = tmpMsg[1] = key.replace(new RegExp('^this/'), "" + con.peerPath + "/");
          }
          isMyPeerKey = key.match("^" + con.peerPath + "/");
          if (!isMyPeerKey && !noLinks && key.match("^peer/") && !key.match("^.*/public(/|$)")) {
            return this.primDisconnect(con, error_private_variable, "Error, " + con.name + " (key = " + key + ", peerPath = " + con.peerPath + ", match = " + (key.match("^" + con.peerPath)) + ") attempted to change another peer's private variable: '" + key + "' in message: " + (JSON.stringify(msg)));
          } else {
            if (isMyPeerKey) {
              switch (key) {
                case con.listenPath:
                  this.newListens = true;
                  break;
                case !noLinks && con.linksPath:
                  this.verbose("Setting links: " + msg);
                  this.newConLinks = true;
              }
            }
            if (!noLinks && this.linksToPeers[key]) {
              if (!this.changedLinks) {
                this.changedLinks = {};
              }
              this.changedLinks[key] = true;
            }
            if (name !== 'response' && this.shouldDelegate(con, key)) {
              return this.delegate(con, msg);
            } else {
              this.verbose("EXECUTING: " + (JSON.stringify(msg)));
              return this[name](con, msg, function() {
                var c, _i, _len, _ref;
                if (__indexOf.call(setCmds, name) >= 0) {
                  _this.verbose("CMD: " + (JSON.stringify(msg)) + ", VALUE: " + (JSON.stringify(_this.varStorage.values[key])));
                  if (key === con.namePath) {
                    _this.name(con, msg[2]);
                  } else if (key === con.masterPath) {
                    _this.setMaster(con, msg[2]);
                  }
                  _ref = _this.relevantConnections(prefixes(key));
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    c = _ref[_i];
                    c.addCmd(msg);
                  }
                  if (_this.varStorage.keyInfo[key] === storage_permanent) {
                    return _this.store(con, key, value);
                  }
                }
              });
            }
          }
        } else {
          return this.primDisconnect(con, error_bad_message, "Unknown command, '" + name + "' in message: " + (JSON.stringify(msg)));
        }
      } else if (noLinks) {
        x = msg[0], key = msg[1];
        if (!key.match(new RegExp("^this|^peer/" + con.peerPath + "/"))) {
          return this[name](con, msg, function() {
            var c, _i, _len, _ref, _results;
            _this.verbose("EXECUTED: " + msg);
            _ref = _this.relevantConnections(prefixes(key));
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              c = _ref[_i];
              _results.push(c.addCmd(msg));
            }
            return _results;
          });
        }
      }
    };

    Server.prototype.shouldDelegate = function(con, key) {
      var match;
      if (this.isPeerVar(key)) {
        match = key.match(/^peer\/([^/]+)\//);
        return this.peers[match[1]] !== con;
      } else {
        return false;
      }
    };

    Server.prototype.isPeerVar = function(key) {
      var _this = this;
      return _.any(prefixes(key), function(k) {
        return _this.varStorage.keyInfo[k] === storage_peer;
      });
    };

    Server.prototype.relevantConnections = function(keyPrefixes) {
      return _.filter(this.connections, function(c) {
        return caresAbout(c, keyPrefixes);
      });
    };

    Server.prototype.setConName = function(con, name) {
      con.name = name;
      con.peerPath = "peer/" + name;
      con.namePath = "" + con.peerPath + "/name";
      con.listenPath = "" + con.peerPath + "/listen";
      con.linksPath = "" + con.peerPath + "/links";
      con.masterPath = "" + con.peerPath + "/master";
      con.requests = {};
      this.peers[name] = con;
      return this.varStorage.setKey(con.namePath, name);
    };

    Server.prototype.addConnection = function(con) {
      this.verbose("Xus add connection");
      this.setConName(con, "@anonymous-" + (this.anonymousPeerCount++));
      con.listening = {};
      con.links = {};
      this.connections.push(con);
      this.varStorage.setKey(con.listenPath, []);
      con.date = new Date().getTime();
      con.addCmd(['set', 'this/name', con.name, con.date]);
      return con.send();
    };

    Server.prototype.renamePeerKeys = function(con, oldName, newName) {
      var l, newCL, newPrefix, newVL, oldPrefixPat;
      this.varStorage.keys = renameVars(this.varStorage.keys, this.varStorage.values, this.varStorage.handlers, oldName, newName)[0];
      newCL = {};
      newVL = [];
      newPrefix = "peer/" + newName;
      oldPrefixPat = new RegExp("^peer/" + oldName + "(?=/|$)");
      for (l in con.listening) {
        l = l.replace(oldPrefixPat, newPrefix);
        newCL[l] = true;
        newVL.push(l);
      }
      con.listening = newCL;
      newVL.sort();
      return this.varStorage.setKey("" + newPrefix + "/listen", newVL);
    };

    Server.prototype.disconnect = function(con, errorType, msg) {
      this.primDisconnect(con, errorType, msg);
      if (this.nextBatch) {
        return this.processBatch(con, this.nextBatch, true);
      }
    };

    Server.prototype.primDisconnect = function(con, errorType, msg) {
      var batch, idx, key, num, peerKey, peerKeys, _i, _j, _len, _len1, _ref;
      idx = this.connections.indexOf(con);
      batch = [];
      if (idx > -1) {
        this.varStorage.setKey(con.linksPath, []);
        batch = this.setLinks(con);
        peerKey = con.peerPath;
        peerKeys = this.varStorage.keysForPrefix(peerKey);
        if (con.name) {
          delete this.peers[con.name];
        }
        for (_i = 0, _len = peerKeys.length; _i < _len; _i++) {
          key = peerKeys[_i];
          this.varStorage.removeKey(key);
        }
        this.connections.splice(idx, 1);
        if (msg) {
          this.error(con, errorType, msg);
        }
        con.send();
        con.close();
        _ref = con.requests;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          num = _ref[_j];
          delete this.pendingRequests[num];
        }
        if (con === this.master) {
          this.exit();
        }
      }
      return false;
    };

    Server.prototype.exit = function() {
      return console.log("No custom exit function");
    };

    Server.prototype.setListens = function(con) {
      var conPath, finalListen, old, path, thisPath, _i, _len, _ref;
      thisPath = new RegExp("^this/");
      conPath = "" + con.peerPath + "/";
      old = con.listening;
      con.listening = {};
      finalListen = [];
      _ref = this.varStorage.values[con.listenPath];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        if (path.match("^peer/") && !path.match("^peer/[^/]+/public") && !path.match("^" + con.peerPath)) {
          this.primDisconnect(con, error_private_variable, "Error, " + con.name + " attempted to listen to a peer's private variables in message: " + (JSON.stringify(msg)));
          return;
        }
        path = path.replace(thisPath, conPath);
        finalListen.push(path);
        con.listening[path] = true;
        if (_.all(prefixes(path), (function(p) {
          return !old[p];
        }))) {
          this.sendTree(con, path, ['value', path, null, true]);
        }
        old[path] = true;
      }
      return this.varStorage.setKey(con.listenPath, finalListen);
    };

    Server.prototype.setLinks = function(con) {
      var l, old, _i, _len, _ref, _results;
      this.verbose("PRIM SET LINKS, LINKS PATH: " + con.linksPath + ", NEW " + (JSON.stringify(this.varStorage.values[con.linksPath])) + ", OLD: " + (JSON.stringify(con.links)));
      old = {};
      for (l in con.links) {
        old[l] = true;
      }
      _ref = this.varStorage.values[con.linksPath];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        if (!old[l]) {
          this.addLink(con, l);
        } else {
          delete old[l];
        }
      }
      _results = [];
      for (l in old) {
        _results.push(this.removeLink(con, l));
      }
      return _results;
    };

    Server.prototype.processLinks = function(con, changed) {
      var l, link, old, p, _i, _len, _ref, _results;
      _results = [];
      for (link in changed) {
        old = {};
        for (l in this.linksToPeers[link]) {
          old[l] = true;
        }
        _ref = this.varStorage.values[link];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          if (!old[p]) {
            this.addLink(this.peers[p], link);
          } else {
            delete old[p];
          }
        }
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (p in old) {
            _results1.push(this.removeLink(this.peers[p], link));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Server.prototype.addLink = function(con, link) {
      this.verbose("ADDING LINK: " + (JSON.stringify(link)));
      if (!this.linksToPeers[link]) {
        this.linksToPeers[link] = {};
      }
      this.linksToPeers[link][con.name] = con.links[link] = true;
      this.nextBatch.push(['splice', link, -1, 0, con.name]);
      return this.nextBatch.push(['splice', "peer/" + con.name + "/links", -1, 0, link]);
    };

    Server.prototype.removeLink = function(con, link) {
      var _ref;
      this.verbose("REMOVING LINK: " + (JSON.stringify(link)));
      delete con.links[link];
      if ((_ref = this.linksToPeers[link]) != null) {
        delete _ref[con.name];
      }
      if (this.linksToPeers[link] && !this.linksToPeers[link].length) {
        delete this.linksToPeers[link];
      }
      this.nextBatch.push(['removeAll', link, con.name]);
      return this.nextBatch.push(['removeAll', "peer/" + con.name + "/links", link]);
    };

    Server.prototype.error = function(con, errorType, msg) {
      con.addCmd(['error', errorType, msg]);
      return false;
    };

    Server.prototype.sendTree = function(con, path, cmd) {
      return this.handleStorageCommand(con, cmd, function() {
        return con.addCmd(cmd);
      });
    };

    Server.prototype.delegate = function(con, cmd) {
      var key, match, num, peer, x;
      x = cmd[0], key = cmd[1];
      if (match = key.match(/^peer\/([^/]+)\//)) {
        this.verbose("DELEGATING: " + (JSON.stringify(cmd)));
        peer = this.peers[match[1]];
        num = this.pendingRequestNum++;
        peer.requests[num] = true;
        this.pendingRequests[num] = [peer, con];
        return peer.addCmd(['request', con.name, num, cmd]);
      } else {
        return this.error(con, error_bad_peer_request, "Bad request: " + cmd);
      }
    };

    Server.prototype.get = function(key) {
      return this.varStorage.values[key];
    };

    Server.prototype.name = function(con, name) {
      if (name == null) {
        return this.primDisconnect(con, error_bad_message, "No name given in name message");
      } else if (this.peers[name]) {
        return this.primDisconnect(con, error_duplicate_peer_name, "Duplicate peer name: " + name);
      } else {
        delete this.peers[con.name];
        this.renamePeerKeys(con, con.name, name);
        this.setConName(con, name);
        return con.addCmd(['set', 'this/name', name]);
      }
    };

    Server.prototype.setMaster = function(con, value) {
      if ((this.master != null) && this.master !== con) {
        return this.primDisconnect(con, error_bad_master, "Xus cannot serve two masters");
      } else {
        this.master = value ? con : null;
        return con.addCmd(['set', 'this/master', value]);
      }
    };

    Server.prototype.value = function(con, cmd, cont) {
      var key, x;
      x = cmd[0], key = cmd[1];
      if (this.isPeerVar(key)) {
        return this.delegate(con, [cmd], cont);
      } else {
        return this.handleStorageCommand(con, cmd, function() {
          con.addCmd(cmd);
          return cont();
        });
      }
    };

    Server.prototype.set = function(con, cmd, cont) {
      var key, oldInfo, storageMode, value, x;
      x = cmd[0], key = cmd[1], value = cmd[2], storageMode = cmd[3];
      if (storageMode && storageModes.indexOf(storageMode) === -1) {
        return this.error(con, error_bad_storage_mode, "" + storageMode + " is not a valid storage mode");
      } else if (this.varStorage.values[key] === value) {
        return false;
      } else {
        if (storageMode && storageMode !== this.varStorage.keyInfo[key] && this.varStorage.keyInfo[key] === storage_permanent) {
          this.remove(con, key);
        }
        oldInfo = this.varStorage.keyInfo[key];
        this.varStorage.keyInfo[key] = storageMode = storageMode || this.varStorage.keyInfo[key] || storage_memory;
        if (storageMode !== storage_transient) {
          if (!oldInfo) {
            this.varStorage.keys.push(key);
            this.newKeys = true;
          }
          return this.handleStorageCommand(con, cmd, function() {
            cmd[2] = value;
            return cont();
          });
        } else {
          return cont();
        }
      }
    };

    Server.prototype.put = function(con, cmd, cont) {
      return this.handleStorageCommand(con, cmd, cont);
    };

    Server.prototype.splice = function(con, cmd, cont) {
      return this.handleStorageCommand(con, cmd, cont);
    };

    Server.prototype.removeFirst = function(con, cmd, cont) {
      var key, value, x;
      x = cmd[0], key = cmd[1], value = cmd[2];
      if (!this.varStorage.canRemove(key)) {
        return this.primDisconnect(con, error_variable_not_array, "Can't insert into " + key + " because it does not support splice and indexOf");
      } else {
        return this.handleStorageCommand(con, cmd, cont);
      }
    };

    Server.prototype.removeAll = function(con, cmd, cont) {
      return this.handleStorageCommand(con, cmd, cont);
    };

    Server.prototype.response = function(con, rcmd, cont) {
      var arg, c, cmd, cmdName, id, key, peer, receiver, x, _i, _len, _ref, _ref1;
      x = rcmd[0], id = rcmd[1], cmd = rcmd[2];
      _ref = this.pendingRequests[id], peer = _ref[0], receiver = _ref[1];
      delete this.pendingRequests[id];
      if (peer !== con) {
        return this.primDisconnect(peer, error_bad_peer_request, "Attempt to responsd to an invalid request");
      } else {
        delete peer.requests[id];
        if (cmd != null) {
          cmdName = cmd[0], key = cmd[1], arg = cmd[2];
          if (cmdName === 'error' && key === error_bad_peer_request) {
            this.primDisconnect(receiver, key, arg);
          } else if (cmdName === 'error' || cmdName === 'value') {
            receiver.addCmd(cmd);
          } else {
            _ref1 = this.relevantConnections(prefixes(key));
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              c = _ref1[_i];
              c.addCmd(msg);
            }
          }
        }
        return cont();
      }
    };

    Server.prototype.handleStorageCommand = function(con, cmd, cont) {
      var _this = this;
      return this.varStorage.handle(cmd, (function(type, msg) {
        return _this.primDisconnect(con, type, msg);
      }), cont);
    };

    return Server;

  })();

  exports.VarStorage = VarStorage = (function() {
    function VarStorage(owner) {
      this.owner = owner;
      this.keys = [];
      this.values = {};
      this.handlers = {};
      this.keyInfo = {};
      this.newKeys = false;
    }

    VarStorage.prototype.toString = function() {
      return "A VarStorage";
    };

    VarStorage.prototype.verbose = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.owner).verbose.apply(_ref, args);
    };

    VarStorage.prototype.handle = function(cmd, errBlock, cont) {
      var args, key, name;
      name = cmd[0], key = cmd[1], args = 3 <= cmd.length ? __slice.call(cmd, 2) : [];
      return this.handlerFor(key)[name](cmd, errBlock, cont);
    };

    VarStorage.prototype.handlerFor = function(key) {
      var handler, k,
        _this = this;
      k = _.find(prefixes(key), function(p) {
        return _this.handlers[p];
      });
      handler = k ? this.handlers[k] : this;
      return handler;
    };

    VarStorage.prototype.addKey = function(key, info) {
      console.log("ADD KEY: " + key);
      if (!this.keyInfo[key]) {
        this.newKeys = true;
        this.keyInfo[key] = info;
        this.keys.push(key);
      } else {
        console.log("KEY " + key + " ALREADY PRESENT");
      }
      return info;
    };

    VarStorage.prototype.sortKeys = function() {
      if (this.newKeys) {
        this.keys.sort();
        return this.newKeys = false;
      }
    };

    VarStorage.prototype.setKey = function(key, value, info) {
      var obj;
      if (typeof value === 'function') {
        obj = this.addHandler(key, {
          put: function(_arg, errBlock, cont) {
            var args, err, result, x;
            x = _arg[0], args = 2 <= _arg.length ? __slice.call(_arg, 1) : [];
            try {
              result = value.apply(null, args);
            } catch (_error) {
              err = _error;
              return errBlock(error_bad_peer_request, "Error in computed value: " + (err.stack ? err.stack.join('\n') : err));
            }
            return cont(result);
          }
        });
        obj.set = obj.get = obj.put;
      } else {
        this.values[key] = value;
      }
      this.addKey(key, info || storage_memory);
      return value;
    };

    VarStorage.prototype.removeKey = function(key) {
      var idx;
      delete this.keyInfo[key];
      delete this.values[key];
      idx = _.sortedIndex(key, this.keys);
      if (idx > -1) {
        return this.keys.splice(idx, 1);
      }
    };

    VarStorage.prototype.isObject = function(key) {
      return typeof this.values[key] === 'object';
    };

    VarStorage.prototype.canSplice = function(key) {
      return !this.values[key] || ((this.values[key].splice != null) && (this.values[key].length != null));
    };

    VarStorage.prototype.canRemove = function(key) {
      return canSplice(key) && (this.values[key].indexOf != null);
    };

    VarStorage.prototype.contains = function(key) {
      return this.values[key] != null;
    };

    VarStorage.prototype.keysForPrefix = function(pref) {
      return keysForPrefix(this.keys, this.values, pref);
    };

    VarStorage.prototype.addHandler = function(path, obj) {
      obj.__proto__ = this;
      obj.toString = function() {
        return "A Handler for " + path;
      };
      this.handlers[path] = obj;
      this.addKey(path, 'handler');
      return obj;
    };

    VarStorage.prototype.value = function(cmd, errBlock, cont) {
      var blk, cookie, counter, key, keys, path, tree, x, _i, _len;
      x = cmd[0], path = cmd[1], cookie = cmd[2], tree = cmd[3];
      if (tree) {
        console.log("KEYS: " + this.keys);
        keys = this.keysForPrefix(path);
        console.log("GETTING VALUES FOR PATH: " + path + " KEYS: " + (JSON.stringify(keys)) + ", ALL KEYS: " + this.keys);
        counter = keys.length;
        blk = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          counter = 0;
          return errBlock.apply(null, args);
        };
        if (counter) {
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            key = keys[_i];
            this.handle(['get', key], blk, function(v) {
              console.log("VALUE FOR " + key + " IS " + v);
              if (v) {
                cmd.push(key, v);
              }
              if (--counter === 0) {
                return cont(cmd);
              }
            });
            if (counter < 1) {
              return;
            }
          }
        } else {
          cont(cmd);
        }
      } else {
        this.handle(['get', path], errBlock, function(v) {
          if (v) {
            cmd.push(path, v);
          }
          return cont(cmd);
        });
      }
      return cmd;
    };

    VarStorage.prototype.get = function(_arg, errBlock, cont) {
      var key, x;
      x = _arg[0], key = _arg[1];
      return cont(this.values[key]);
    };

    VarStorage.prototype.set = function(cmd, errBlock, cont) {
      var info, key, oldInfo, storageMode, value, x;
      x = cmd[0], key = cmd[1], value = cmd[2], info = cmd[3];
      if (storageMode && storageModes.indexOf(storageMode) === -1) {
        return errBlock(error_bad_storage_mode, "" + storageMode + " is not a valid storage mode");
      } else {
        oldInfo = this.keyInfo[key];
        this.keyInfo[key] = storageMode = storageMode || this.keyInfo[key] || storage_memory;
        cmd[2] = value;
        if (storageMode !== storage_transient) {
          if (!oldInfo) {
            this.keys.push(key);
            this.newKeys = true;
          }
          return cont(this.setKey(key, value, info));
        }
      }
    };

    VarStorage.prototype.put = function(_arg, errBlock, cont) {
      var index, key, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2], index = _arg[3];
      if (!this.values[key]) {
        this.values[key] = {};
      }
      if (typeof this.values[key] !== 'object' || this.values[key] instanceof Array) {
        return errBlock(error_variable_not_object("" + key + " is not an object"));
      } else {
        return cont(this.values[key][index] = value);
      }
    };

    VarStorage.prototype.splice = function(_arg, errBlock, cont) {
      var args, key, x, _ref;
      x = _arg[0], key = _arg[1], args = 3 <= _arg.length ? __slice.call(_arg, 2) : [];
      this.verbose("SPLICING: " + (JSON.stringify([x, key].concat(__slice.call(args)))));
      if (!this.values[key]) {
        this.values[key] = [];
      }
      if (typeof this.values[key] !== 'object' || !(this.values[key] instanceof Array)) {
        return errBlock(error_variable_not_array, "" + key + " is not an array");
      } else {
        if (args[0] < 0) {
          args[0] = this.values[key].length + args[0] + 1;
        }
        (_ref = this.values[key]).splice.apply(_ref, args);
        return cont(this.values[key]);
      }
    };

    VarStorage.prototype.removeFirst = function(_arg, errBlock, cont) {
      var idx, key, val, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2];
      if (typeof this.values[key] !== 'object' || !(this.values[key] instanceof Array)) {
        return errBlock(error_variable_not_array, "" + key + " is not an array");
      } else {
        val = this.values[key];
        idx = val.indexOf(value);
        if (idx > -1) {
          val.splice(idx, 1);
        }
        return cont(val);
      }
    };

    VarStorage.prototype.removeAll = function(_arg, errBlock, cont) {
      var idx, key, val, value, x;
      x = _arg[0], key = _arg[1], value = _arg[2];
      if (typeof this.values[key] !== 'object' || !(this.values[key] instanceof Array)) {
        return errBlock(error_variable_not_array, "" + key + " is not an array");
      } else {
        val = this.values[key];
        while ((idx = val.indexOf(value)) > -1) {
          val.splice(idx, 1);
        }
        return cont(val);
      }
    };

    return VarStorage;

  })();

  exports.renameVars = renameVars = function(keys, values, handlers, oldName, newName) {
    var k, key, newKey, newPrefix, oldPrefix, oldPrefixPat, trans, _i, _len, _ref;
    oldPrefix = "peer/" + oldName;
    newPrefix = "peer/" + newName;
    oldPrefixPat = new RegExp("^" + oldPrefix + "(?=/|$)");
    trans = {};
    _ref = keysForPrefix(keys, values, oldPrefix);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      newKey = key.replace(oldPrefixPat, newPrefix);
      values[newKey] = values[key];
      handlers[newKey] = handlers[key];
      trans[key] = newKey;
      delete values[key];
      delete handlers[key];
    }
    keys = (function() {
      var _results;
      _results = [];
      for (k in values) {
        _results.push(k);
      }
      return _results;
    })();
    keys.sort();
    return [keys, trans];
  };

  keysForPrefix = function(keys, values, prefix) {
    var idx, initialPattern, prefixPattern, result, _i, _ref, _ref1, _results;
    initialPattern = "^" + prefix + "(/|$)";
    result = [];
    idx = _.find((function() {
      _results = [];
      for (var _i = 0, _ref = keys.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), function(i) {
      return keys[i].match(initialPattern);
    });
    if (idx > -1) {
      prefixPattern = "^" + prefix + "/";
      idx--;
      while ((_ref1 = keys[++idx]) != null ? _ref1.match(prefixPattern) : void 0) {
        if (values[keys[idx]] != null) {
          result.push(keys[idx]);
        }
      }
    }
    return result;
  };

  caresAbout = function(con, keyPrefixes) {
    return _.any(keyPrefixes, function(p) {
      return con.listening[p];
    });
  };

  exports.prefixes = prefixes = function(key) {
    var result, splitKey;
    result = [];
    splitKey = _.without(key.split('/'), '');
    while (splitKey.length) {
      result.push(splitKey.join('/'));
      splitKey.pop();
    }
    return result;
  };

}).call(this);

/*
//@ sourceMappingURL=proto.map
*/
