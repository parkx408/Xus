// Generated by CoffeeScript 1.6.3
(function() {
  var FdConnection, Server, exports, log, parseAddr, path, pfs, run, setup, startProxy, startWebSocketServer, startXus, state, stateFd, usage,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require('source-map-support').install();

  log = (exports = module.exports = require('./base')).log;

  startWebSocketServer = require('./websocket').startWebSocketServer;

  Server = (exports = require('./peer')).Server;

  pfs = require('./pfs');

  path = require('path');

  usage = function(args) {
    console.log("Usage: node " + args[1] + " name [-p port]");
    return process.exit();
  };

  stateFd = null;

  state = null;

  setup = function(cont) {
    var err, stateFile, xusDir;
    try {
      xusDir = path.join(process.env.HOME, '.xus');
      stateFile = path.join(xusDir, 'state');
      return pfs.stat(xusDir).fail(function() {
        return pfs.mkdir(xusDir);
      }).then(function() {
        return pfs.open(stateFile, 'a+');
      }).then(function(fd) {
        return pfs.flock((stateFd = fd), 'ex');
      }).then(function() {
        return pfs.readFile(stateFd);
      }).then(function(s) {
        return (cont || function() {})(s);
      }).done();
    } catch (_error) {
      err = _error;
      return console.log("Error: " + err.stack);
    }
  };

  run = function() {
    return setup(function(s) {
      var args, config, dir, httpServer, i, pattern, requirements, _ref;
      config = {
        diag: false,
        proxy: false,
        verbose: function() {},
        addr: null,
        cmd: null,
        args: []
      };
      state = (s && JSON.parse(s)) || {
        servers: {}
      };
      i = 2;
      args = process.argv;
      if (i > args.length) {
        usage(args);
      }
      config.name = args[1];
      if (state.servers[config.name]) {
        console.log("Error: there is already a server named " + config.name);
        return process.exit(2);
      } else {
        requirements = [];
        while (i < args.length) {
          switch (args[i]) {
            case '-w':
              config.addr = args[++i];
              break;
            case '-e':
              requirements.push(args[++i]);
              break;
            case '-x':
              config.cmd = args[++i];
              break;
            case '-v':
              config.verbose = log;
              break;
            case '-p':
              config.proxy = true;
              break;
            case '-u':
              pattern = new RegExp("^" + args[++i] + "/");
              dir = path.resolve(args[++i]);
              exports.addDirHandler(pattern, dir);
              break;
            case '-t':
              config.diag = true;
              console.log("Diag mode activated");
              break;
            default:
              config.args = args.slice(i);
              i = args.length;
          }
          i++;
        }
        _ref = parseAddr(config.addr || ':'), config.host = _ref[0], config.port = _ref[1];
        httpServer = startWebSocketServer(config, function() {
          console.log("Server " + config.name + " started on port: " + (httpServer.address().port));
          process.env.XUS_SERVER = config.name;
          process.env.XUS_PORT = httpServer.address().port;
          state.servers[config.name] = httpServer.address();
          state.servers[config.name].pid = process.pid;
          return pfs.truncate(stateFd, 0).then(function() {
            return pfs.writeFile(stateFd, JSON.stringify(state));
          }).then(function() {
            return pfs.close(stateFd);
          }).then(function() {
            if (config.cmd != null) {
              return require('child_process').spawn('/bin/sh', ['-c', config.cmd], {
                stdio: ['ignore', 1, 2]
              });
            } else {
              return 1;
            }
          }).done();
        });
        return (config.proxy ? startProxy : startXus)(config, httpServer, function(master) {
          var file, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = requirements.length; _i < _len; _i++) {
            file = requirements[_i];
            _results.push(require(file).main(master, config));
          }
          return _results;
        });
      }
    });
  };

  startXus = function(config, httpServer, thenBlock) {
    var xusServer;
    exports.xusServer = xusServer = new Server(config.name);
    xusServer.diag = config.diag;
    xusServer.exit = function() {
      return process.exit();
    };
    xusServer.verbose = config.verbose;
    xusServer.verbose("Starting Xus");
    exports.connectXus(xusServer, httpServer);
    exports.addXusCometHandler(xusServer, new RegExp("^/_comet.io"));
    return thenBlock(xusServer);
  };

  startProxy = function(config, httpServer, thenBlock) {
    if (config.verbose) {
      console.log("Starting proxy");
    }
    return exports.connectProxy(config, httpServer, thenBlock);
  };

  parseAddr = function(addr) {
    var host, parts, port, _ref;
    _ref = parts = addr.split(':'), host = _ref[0], port = _ref[1];
    if (parts.length > 2) {
      throw new Error("Bad address format, expected [host:]port, but got " + addr);
    }
    return (port && [host || null, port]) || [null, host || null];
  };

  exports.FdConnection = FdConnection = (function(_super) {
    __extends(FdConnection, _super);

    function FdConnection(input, output) {
      this.input = input;
      this.output = output;
      FdConnection.__super__.constructor.call(this, null, this["null"]);
      this.q = [];
      this.writing = false;
    }

    FdConnection.prototype.setMaster = function(master) {
      this.master = master;
      if (this.master) {
        this.master.addConnection(this);
        return this.read(new Buffer(65536));
      }
    };

    FdConnection.prototype.basicClose = function() {
      fs.close(this.input, function(err) {
        return console.log("Error closing connection: " + err.stack);
      });
      return fs.close(this.output, function(err) {
        return console.log("Error closing connection: " + err.stack);
      });
    };

    FdConnection.prototype.connected = true;

    FdConnection.prototype.read = function(buf) {
      var _this = this;
      return fs.read(this.input, buf, 0, buf.length, null, function(err, bytesRead) {
        if (err) {
          _this.verbose("" + (d(_this)) + " disconnect");
          return _this.master.disconnect(_this);
        } else {
          _this.verbose("" + (d(_this)) + " data '" + data + "'");
          _this.newData(buf.toString(null, 0, bytesRead));
          return _this.read(buf);
        }
      });
    };

    FdConnection.prototype.write = function(str) {
      if (str.length) {
        this.q.push(str);
        if (!this.writing) {
          this.writing = true;
          return this.writeNext();
        }
      }
    };

    FdConnection.prototype.writeNext = function() {
      var buf;
      buf = new Buffer(this.q[0]);
      splice(this.q, 0, 1);
      return writeBuffer(buf);
    };

    FdConnection.prototype.writeBuffer = function(buf) {
      var _this = this;
      return fs.write(this.output, buf, 0, buf.length, null, function(err, written) {
        if (err) {
          _this.verbose("" + (d(_this)) + " disconnect");
          return _this.master.disconnect(_this);
        } else if (written < buf.length) {
          return _this.writeBuffer(buf.slice(written));
        } else if (_this.q.length) {
          return _this.writeNext();
        } else {
          return _this.writing = false;
        }
      });
    };

    return FdConnection;

  })(exports.Connection);

  exports.run = run;

  exports.setup = setup;

}).call(this);

/*
//@ sourceMappingURL=main.map
*/
